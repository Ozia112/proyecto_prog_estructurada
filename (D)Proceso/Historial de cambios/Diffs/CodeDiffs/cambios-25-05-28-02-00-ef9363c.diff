commit ef9363c78ae846ab8bd0e6754605d27aed8f159c
Author: Isaac Alejandro Ortiz Zaldivar <a24216345@alumnos.uady.mx>
Date:   Wed May 28 02:00:45 2025 -0600

    Bug fixes and refactor of the Battleship codebase

diff --git a/codigo_fuente/.vscode/launch.json b/codigo_fuente/.vscode/launch.json
index 7b666de..4eb25ab 100644
--- a/codigo_fuente/.vscode/launch.json
+++ b/codigo_fuente/.vscode/launch.json
@@ -5,11 +5,12 @@
       "name": "Ejecutar battleship",
       "type": "cppvsdbg",
       "request": "launch",
-      "program": "${workspaceFolder}/battleship-beta_0.4.3.exe",
-      "console": "externalTerminal",
+      "program": "${workspaceFolder}\\battleship.exe",
+      "args": [],
+      "cwd": "${workspaceFolder}",
       "preLaunchTask": "compilar y ejecutar",
       "stopAtEntry": false,
-      "cwd": "${workspaceFolder}"
+      "console": "externalTerminal"
     }
   ]
-}
+}
\ No newline at end of file
diff --git a/codigo_fuente/.vscode/tasks.json b/codigo_fuente/.vscode/tasks.json
index d661e8b..08166bf 100644
--- a/codigo_fuente/.vscode/tasks.json
+++ b/codigo_fuente/.vscode/tasks.json
@@ -1,17 +1,34 @@
 {
   "version": "2.0.0",
   "tasks": [
+    {
+      "label": "limpiar",
+      "type": "shell",
+      "command": "cmd.exe",
+      "args": [
+        "/d", "/c", 
+        "pushd \"${workspaceFolder}\" && del /f /q *.exe && del /f /q *.o && pushd src && del /f /q *.o && popd && popd"
+      ],
+      "problemMatcher": []
+    },
     {
       "label": "compilar y ejecutar",
       "type": "shell",
-      "command": "cmd",
+      "command": "cmd.exe",
       "args": [
-        "/c", "del /f /q *.exe & gcc main.c .\\bs_common.h .\\bs_logic.c .\\bs_ui.c .\\bs_efectos_cartas.c -o .\\battleship-beta_0.4.3.exe"
+        "/d",
+        "/c",
+        "pushd \"${workspaceFolder}\" && del /f /q *.exe && pushd src && gcc *.c -I\"${workspaceFolder}/include\" -o \"..\\battleship.exe\" && popd && popd"
       ],
-      "group": {
-        "kind": "build",
-        "isDefault": true
-      }
+      "options": {
+        "shell": {
+          "executable": "cmd.exe",
+          "args": ["/d", "/c"]
+        }
+      },
+      "group": { "kind": "build", "isDefault": true },
+      "problemMatcher": ["$gcc"],
+      "dependsOn": ["limpiar"]
     }
   ]
 }
\ No newline at end of file
diff --git a/codigo_fuente/Battleship.zpr b/codigo_fuente/Battleship.zpr
deleted file mode 100644
index 16fc62b..0000000
--- a/codigo_fuente/Battleship.zpr
+++ /dev/null
@@ -1,113 +0,0 @@
-# generated by ZinjaI-w32-20191006
-[general]
-project_name=Battleship
-help_page=
-autocodes_file=
-macros_file=
-default_fext_source=cpp
-default_fext_header=h
-autocomp_extra=
-active_configuration=Debug
-version_saved=20191006
-version_required=20140318
-tab_width=4
-tab_use_spaces=0
-explorer_path=.
-inherits_from=
-path_char=\
-[source]
-path=bs_efectos_cartas.c
-cursor=0:0
-[source]
-path=bs_logic.c
-cursor=0:0
-[source]
-path=bs_ui.c
-cursor=0:0
-[source]
-path=main.c
-cursor=0:0
-[header]
-path=bs_common.h
-cursor=0:0
-[header]
-path=bs_console_utils.h
-cursor=0:0
-[header]
-path=bs_efectos_cartas.h
-cursor=0:0
-[header]
-path=bs_logic.h
-cursor=0:0
-[header]
-path=bs_ui.h
-cursor=0:0
-[other]
-path=Battleship.zpr
-cursor=0:0
-[config]
-name=Debug
-toolchain=
-working_folder=
-always_ask_args=0
-args=
-exec_method=0
-exec_script=
-env_vars=
-wait_for_key=2
-temp_folder=Debug
-output_file=${TEMP_DIR}\Battleship.exe
-icon_file=
-manifest_file=
-compiling_extra=
-macros=_DEBUG
-warnings_level=2
-warnings_as_errors=0
-pedantic_errors=0
-std_c=
-std_cpp=c++14
-debug_level=2
-optimization_level=0
-enable_lto=0
-headers_dirs=
-linking_extra=
-libraries_dirs=
-libraries=
-libs_to_use=
-strip_executable=0
-console_program=1
-dont_generate_exe=0
-[config]
-name=Release
-toolchain=
-working_folder=
-always_ask_args=0
-args=
-exec_method=0
-exec_script=
-env_vars=
-wait_for_key=2
-temp_folder=Release
-output_file=${TEMP_DIR}\Battleship.exe
-icon_file=
-manifest_file=
-compiling_extra=
-macros=
-warnings_level=2
-warnings_as_errors=0
-pedantic_errors=0
-std_c=
-std_cpp=c++14
-debug_level=0
-optimization_level=2
-enable_lto=0
-headers_dirs=
-linking_extra=
-libraries_dirs=
-libraries=
-libs_to_use=
-strip_executable=2
-console_program=1
-dont_generate_exe=0
-[custom_tools]
-[end]
diff --git a/codigo_fuente/Debug/Battleship.exe b/codigo_fuente/Debug/Battleship.exe
deleted file mode 100644
index cc237fa..0000000
Binary files a/codigo_fuente/Debug/Battleship.exe and /dev/null differ
diff --git a/codigo_fuente/Debug/bs_efectos_cartas.o b/codigo_fuente/Debug/bs_efectos_cartas.o
deleted file mode 100644
index 82da1ca..0000000
Binary files a/codigo_fuente/Debug/bs_efectos_cartas.o and /dev/null differ
diff --git a/codigo_fuente/Debug/bs_logic.o b/codigo_fuente/Debug/bs_logic.o
deleted file mode 100644
index 8b2ec6e..0000000
Binary files a/codigo_fuente/Debug/bs_logic.o and /dev/null differ
diff --git a/codigo_fuente/Debug/bs_ui.o b/codigo_fuente/Debug/bs_ui.o
deleted file mode 100644
index eca7b6c..0000000
Binary files a/codigo_fuente/Debug/bs_ui.o and /dev/null differ
diff --git a/codigo_fuente/Debug/main.o b/codigo_fuente/Debug/main.o
deleted file mode 100644
index 69534ce..0000000
Binary files a/codigo_fuente/Debug/main.o and /dev/null differ
diff --git a/codigo_fuente/bs_efectos_cartas.c b/codigo_fuente/bs_efectos_cartas.c
deleted file mode 100644
index 22a316d..0000000
--- a/codigo_fuente/bs_efectos_cartas.c
+++ /dev/null
@@ -1,271 +0,0 @@
-#include "bs_console_utils.h" // libreria para poder usar la funcion limpiar y cambio de color.
-#include "bs_efectos_cartas.h" // libreria para poder usar funciones de efectos de cartas.
-#include "bs_ui.h" // libreria para poder usar funciones de UI.
-#include "bs_logic.h" // libreria para poder usar funciones de logica.
-#include <windows.h> // libreria para poder usar la funcion Sleep.
-#include <stdio.h> // libreria para poder usar la funcion printf.
-#include <time.h> // libreria para poder usar la funcion time.
-#include <stdbool.h> // libreria para poder usar la funcion bool.
-
-void disparar(struct player *player_i, struct player *enemy_i, int fila, int columna) {
-    for (int i = 0; i < NUM_SHIPS; i++) {
-        for (int j = 0; j < enemy_i->ships[i].size; j++) {
-            if (player_i->buff) {
-                if (enemy_i->ships[i].status[j][0] == fila && enemy_i->ships[i].status[j][1] == columna) {
-                    // Solo daña si no está ya dañado
-                    if (enemy_i->ships[i].status[j][CC_STATUS] == SHIP_STER || enemy_i->ships[i].status[j][CC_STATUS] == SHIP_BODY) {
-                        // Modifica el estado de la parte del barco a dañada (con validaciones)
-                        if (enemy_i->ships[i].status[j][CC_STATUS] == SHIP_STER) {
-                            // Modifica todo el barco a hundido
-                            enemy_i->ships[i].status[j][CC_STATUS] = SHIP_STER_D;
-                        } else if (enemy_i->ships[i].status[j][CC_STATUS] == SHIP_BODY) {
-                            // Modifica todo el barco a hundido
-                            enemy_i->ships[i].status[j][CC_STATUS] = SHIP_BODY_D;
-                        }
-                        printf("Disparo exitoso en %d,%c!\n", fila + 1, columna + 'A');
-                        player_i->enemy_hit_parts++;
-                        hundido(enemy_i, player_i); // Verifica si el barco está hundido
-                    }
-                }
-                
-            } else {
-                if (enemy_i->ships[i].status[j][0] == fila && enemy_i->ships[i].status[j][1] == columna) {
-                    // Modifica el estado de la parte del barco a dañada (sin validaciones)
-                    enemy_i->ships[i].status[j][CC_STATUS] += 2;
-                    printf("Disparo exitoso en %d,%c!\n", fila + 1, columna + 'A');
-                    player_i->enemy_hit_parts++;
-                    hundido(enemy_i, player_i); // Verifica si el barco está hundido
-                }
-            }
-            
-        }
-    }
-}
-
-bool barco_cuatro_aflote(struct player *player_i) {
-    int casillas_buenas = 4;
-    // ship[1] = barco de 4 casillas
-    for (int i = 0; i < player_i->ships[1].size; i++) {
-        if (player_i->ships[1].status[i][CC_STATUS] == SHIP_STER_D || player_i->ships[1].status[i][CC_STATUS] == SHIP_BODY_D) { // 3 o 4 = no dañado
-            casillas_buenas--;
-        }
-        if (casillas_buenas == 0) {
-            return false; // Barco de 4 casillas no está a flote
-            break;
-        }
-    }
-    return true; // Barco de 4 casillas está a flote
-}
-
-void bombardea_fila(struct player *player_i, struct player *enemy_i, int fila) {
-    // Verifica si el jugador tiene su barco de 4 casillas a flote
-
-    if (barco_cuatro_aflote(player_i)) {
-        // Recorre todos los barcos enemigos y daña las partes en la fila dada
-        for (int s = 0; s < NUM_SHIPS; s++) {
-            for (int p = 0; p < enemy_i->ships[s].size; p++) {
-                // Si hay buff, si alguna parte del barco está en la fila, hunde todo el barco
-                if (player_i->buff) {
-                    // Busca en la fila si hay partes de un barco
-                    if (enemy_i->ships[s].status[p][CC_FILA] == fila && (enemy_i->ships[s].status[p][CC_STATUS] == SHIP_STER || enemy_i->ships[s].status[p][CC_STATUS] == SHIP_BODY)) {
-                        for (int k = 0; k < enemy_i->ships[s].size; k++) {
-                            if (enemy_i->ships[s].status[k][CC_STATUS] == 1 || enemy_i->ships[s].status[k][CC_STATUS] == 2) {
-                                if (enemy_i->ships[s].status[k][CC_STATUS] == SHIP_STER) {
-                                    enemy_i->ships[s].status[k][CC_STATUS] = SHIP_STER_D;
-                                } else if (enemy_i->ships[s].status[k][CC_STATUS] == SHIP_BODY) {
-                                    enemy_i->ships[s].status[k][CC_STATUS] = SHIP_BODY_D;
-                                }
-                                player_i->enemy_hit_parts++;
-                            }
-                        }
-                        break; // Ya hundió el barco, no es necesario seguir revisando sus partes
-                    }
-                } 
-                else {
-                    if (enemy_i->ships[s].status[p][CC_FILA] == fila && (enemy_i->ships[s].status[p][CC_STATUS] == SHIP_STER || enemy_i->ships[s].status[p][CC_STATUS] == SHIP_BODY)) {
-                        enemy_i->ships[s].status[p][CC_STATUS] += 2;
-                        player_i->enemy_hit_parts++;
-                    }
-                }
-            }
-        }
-    }
-    else {
-        printf("Al parecer tu barco de 4 casillas no está a flote, por lo que no puedes bombardear la fila.\n");
-        printf("Puedes disparar una vez");
-        capturar_coordenada(player_i, enemy_i);
-    }
-}
-
-bool barco_cinco_aflote(struct player *player_i) {
-    int casillas_buenas = 5;
-    // ship[0] = barco de 5 casillas
-    for (int i = 0; i < player_i->ships[0].size; i++) {
-        if (player_i->ships[0].status[i][CC_STATUS] == 3 || player_i->ships[0].status[i][CC_STATUS] == 4) { // 3 o 4 = no dañado
-            casillas_buenas--;
-        }
-        if (casillas_buenas == 0) {
-            return false; // Barco de 5 casillas no está a flote
-            break;
-        }
-    }
-    return true; // Barco de 5 casillas está a flote
-}
-
-void bombardea_columna(struct player *player_i, struct player *enemy_i, int columna) {
-
-    if (barco_cinco_aflote(player_i)) {
-        // Recorre todos los barcos enemigos y daña las partes en la columna dada
-        for (int s = 0; s < NUM_SHIPS; s++) {
-            for (int p = 0; p < enemy_i->ships[s].size; p++) {
-                if (player_i->buff) {
-                    // Si hay buff, si alguna parte del barco está en la columna, hunde todo el barco
-                    if (enemy_i->ships[s].status[p][CC_COLUMNA] == columna && (enemy_i->ships[s].status[p][CC_STATUS] == 1 || enemy_i->ships[s].status[p][CC_STATUS] == 2)) {
-                        for (int k = 0; k < enemy_i->ships[s].size; k++) {
-                            if (enemy_i->ships[s].status[k][CC_STATUS] == SHIP_STER || enemy_i->ships[s].status[k][CC_STATUS] == SHIP_BODY) {
-                                if (enemy_i->ships[s].status[k][CC_STATUS] == SHIP_STER) {
-                                    enemy_i->ships[s].status[k][CC_STATUS] = SHIP_STER_D;
-                                } else if (enemy_i->ships[s].status[k][CC_STATUS] == SHIP_BODY) {
-                                    enemy_i->ships[s].status[k][CC_STATUS] = SHIP_BODY_D;
-                                }
-                                player_i->enemy_hit_parts++;
-                            }
-                        }
-                        break; // Ya hundió el barco, no es necesario seguir revisando sus partes
-                    }
-                } else {
-                    if (enemy_i->ships[s].status[p][CC_COLUMNA] == columna && (enemy_i->ships[s].status[p][CC_STATUS] == SHIP_STER || enemy_i->ships[s].status[p][CC_STATUS] == SHIP_BODY)) {
-                        enemy_i->ships[s].status[p][CC_STATUS] += 2;
-                        player_i->enemy_hit_parts++;
-                    }
-                }
-            }
-        }
-    } else {
-        printf("Al parecer tu barco de 5 casillas no está a flote, por lo que no puedes bombardear la columna.\n");
-        printf("Puedes disparar una vez");
-        capturar_coordenada(player_i, enemy_i);
-    }
-}
-
-void revela(struct player *enemy_i, struct player *player_i) {
-    // 1. Guardar todas las partes de barco no dañadas
-    int posibles[NUM_SHIPS * 5][2]; // Máximo 5 partes por barco
-    int total = 0;
-    int s, p;
-
-    for (s = 0; s < NUM_SHIPS; s++) {
-        struct ship *barco = &enemy_i->ships[s];
-        for (p = 0; p < barco->size; p++) {
-            // Si la parte no está dañada (1 = punta, 2 = cuerpo)
-            if (barco->status[p][CC_STATUS] == SHIP_STER || barco->status[p][CC_STATUS] == SHIP_BODY) {
-                posibles[total][0] = barco->status[p][CC_FILA]; // fila
-                posibles[total][1] = barco->status[p][CC_COLUMNA]; // columna
-                total++;
-            }
-        }
-    }
-
-    if (total == 0) {
-        printf("No hay partes de barco enemigo sin dañar para revelar.\n");
-        Sleep(1500);
-        return;
-    }
-
-    // 2. Elegir una coordenada aleatoria
-    srand((unsigned int)time(NULL));
-    int idx = rand() % total;
-    int fila = posibles[idx][0];
-    int columna = posibles[idx][1];
-
-    // 3. Mostrar la coordenada revelada
-    printf("Para revelar un barco enemigo\n");
-    color_txt(INFO_COLOR);
-    printf("---> ");
-    color_txt(ERROR_COLOR);
-    printf("(%d,%c)", fila + 1, columna + 'A');
-    color_txt(INFO_COLOR);
-    printf(" <---\n");
-    color_txt(DEFAULT_COLOR);
-    printf("Disparando...\n");
-    Sleep(1000);
-    // 4. Disparar a la coordenada revelada
-    
-    printf("Presione enter para disparar...\n");
-    getchar();
-    for (s = 0; s < NUM_SHIPS; s++) {
-        for (p = 0; p < enemy_i->ships[s].size; p++) {
-            if (enemy_i->ships[s].status[p][CC_FILA] == fila && enemy_i->ships[s].status[p][CC_COLUMNA] == columna) {
-                // Modifica el estado de la parte del barco a dañada (sin validaciones)
-                enemy_i->ships[s].status[p][CC_STATUS] += 2;
-                break;
-            }
-        }
-    }
-    limpiar_pantalla();
-    mostrar_turno_y_tablero(player_i, enemy_i);
-    printf("Disparo exitoso en %d,%c!\n", fila + 1, columna + 'A');
-    player_i->enemy_hit_parts++;
-    hundido(enemy_i, player_i); // Verifica si el barco está hundido
-}
-
-void chequeo_fila(struct player *player_i, struct player *enemy_i, int fila) {
-    player_i->chequeo_fila[fila] = true;
-}
-
-void chequeo_columna(struct player *player_i, struct player *enemy_i, int columna) {
-    player_i->chequeo_columna[columna] = true;
-}
-
-void activar_salvo(struct player *player_i) {
-    player_i->salvo = true;
-}
-
-void desactivar_salvo(struct player *player_i) {
-    player_i->salvo = false;
-}
-
-void torre_ventaja(struct player *player_i) {
-    player_i->buff = true;
-}
-
-void tira_toma(struct player *player_i, struct player *enemy_i) {
-    capturar_coordenada(enemy_i, player_i);
-    Sleep(1000);
-    limpiar_pantalla();
-    printf("Toma otra carta.\n");
-    sacar_carta(player_i, enemy_i);
-}
-
-void mover_barco_adelante(struct player *player_i, int id_barco) {
-    struct ship *ship_i = &player_i->ships[id_barco];
-    int prev_pos[ship_i->size][2];
-    int i;
-
-    // Guardar la posición anterior del barco
-    for (i = 0; i < ship_i->size; i++) {
-        prev_pos[i][0] = ship_i->status[i][0];
-        prev_pos[i][1] = ship_i->status[i][1];
-    }
-
-    if (ship_i->direction == 'E') {
-        ship_i->status[0][1] ++;
-    // Mover barco hacia el oeste
-    } else if (ship_i->direction == 'O') {
-        ship_i->status[0][1] --;
-    // Mover barco hacia el sur
-    } else if (ship_i->direction == 'S') {
-        ship_i->status[0][0] ++;
-    // Mover barco hacia el norte
-    } else if (ship_i->direction == 'N') {
-        ship_i->status[0][0] --;
-    } else {
-        return; // No se puede mover el barco
-    }
-
-    // Mover el resto del barco
-    for (i = 1; i < ship_i->size; i++) {
-        ship_i->status[i][0] = prev_pos[i - 1][0];
-        ship_i->status[i][1] = prev_pos[i - 1][1];
-    }
-}
\ No newline at end of file
diff --git a/codigo_fuente/bs_efectos_cartas.h b/codigo_fuente/bs_efectos_cartas.h
deleted file mode 100644
index b7f725a..0000000
--- a/codigo_fuente/bs_efectos_cartas.h
+++ /dev/null
@@ -1,33 +0,0 @@
-#ifndef BS_EFECTOS_CARTAS_H
-#define BS_EFECTOS_CARTAS_H
-
-#include "bs_common.h" // Incluye definiciones comunes
-#include <stdbool.h> // Incluye definiciones de tipo booleano estándar
-
-void disparar(struct player *player_i, struct player *enemy_i, int fila, int columna);
-
-bool barco_cuatro_aflote(struct player *player_i);
-
-void bombardea_fila(struct player *player_i, struct player *enemy_i, int fila);
-
-bool barco_cinco_aflote(struct player *player_i);
-
-void bombardea_columna(struct player *player_i, struct player *enemy_i, int columna);
-
-void revela(struct player *enemy_i, struct player *player_i);
-
-void chequeo_fila(struct player *player_i, struct player *enemy_i, int fila);
-
-void chequeo_columna(struct player *player_i, struct player *enemy_i, int columna);
-
-void activar_salvo(struct player *player_i);
-
-void desactivar_salvo(struct player *player_i);
-
-void torre_ventaja(struct player *player_i);
-
-void tira_toma(struct player *player_i, struct player *enemy_i);
-
-void mover_barco_adelante(struct player *player_i, int id_barco);
-
-#endif // BS_EFECTOS_CARTAS_H
\ No newline at end of file
diff --git a/codigo_fuente/bs_logic.c b/codigo_fuente/bs_logic.c
deleted file mode 100644
index e1a6521..0000000
--- a/codigo_fuente/bs_logic.c
+++ /dev/null
@@ -1,526 +0,0 @@
-#include "bs_common.h" // libreria para poder usar definiciones comunes.
-#include "bs_logic.h" // libreria para poder usar funciones de logica.
-#include "bs_console_utils.h" // libreria para poder usar la funcion limpiar y cambio de color.
-#include "bs_ui.h" // libreria para poder usar funciones de UI.
-#include "bs_efectos_cartas.h" // libreria para poder usar funciones de efectos de cartas.
-#include <time.h> // libreria para poder usar la funcion time.
-#include <stdio.h> // libreria para poder usar la funcion printf.
-#include <stdlib.h> // libreria para poder usar la funcion system.
-#include <string.h> // libreria para poder usar la funcion strcspn.
-#include <windows.h> // libreria para poder usar la funcion Sleep.s
-
-void inicializar_barco(struct ship *barco, int size) {
-    barco-> size = size;
-    barco->direction = 'U'; // No definido
-    barco->vivo = true; // Barco está vivo al inicio
-
-    // Reservar memoria para el estado del barco.
-    barco->status = (int **)malloc(size * sizeof(int *));
-    for (int i = 0; i < size; i++) {
-        barco->status[i] = (int *)malloc(3 * sizeof(int)); // 3 columnas para x, y y estado
-        barco->status[i][0] = -1; // Inicializar coordenadas x a -1
-        barco->status[i][1] = -1; // Inicializar coordenadas y a -1
-        barco->status[i][2] = 0; // Inicializar estado a 0 (agua)
-    }
-}
-
-void hundido(struct player *enemy_i, struct player *player_i) {
-    for (int i = 0; i < NUM_SHIPS; i++) {
-        if (enemy_i->ships[i].vivo) {
-            bool hundido = true;
-            for (int j = 0; j < enemy_i->ships[i].size; j++) {
-                if (enemy_i->ships[i].status[j][2] != 3 && enemy_i->ships[i].status[j][2] != 4) {
-                    hundido = false; // Si alguna parte no está dañada, no se hunde
-                    break;
-                }
-            }
-            if (hundido) {
-                enemy_i->ships[i].vivo = false; // Barco hundido
-                enemy_i->sunked_ships++;
-                printf("El barco %d ha sido hundido.\n", i + 1);
-                // Desactivar salvo si estaba activo
-                if (enemy_i->salvo) {
-                    enemy_i->salvo = false;
-                    printf("El barco %d ha sido hundido, el modo Salvo se desactiva.\n", i + 1);
-                }
-            }
-        }
-    }
-}
-
-void inicializar_jugador(struct player *player) {
-
-    // Asignar el nombre al jugador, validando que no sea vacío y no exceda 20 caracteres.
-    solicitar_nombre(player);
-
-    // Inicializar estado de jugador.
-    player->placed_ships = 0;
-    player->enemy_hit_parts = 0;
-    player->sunked_ships = 0;
-    player->enemy_hit_parts = 0;
-    player->torres_acumuladas = 0;
-    player->salvo = false;
-    player->buff = false;
-    
-    // chequeo_fila y chequeo_columna inicializados a false.
-    for (int i = 0; i < BOARD_SIZE; i++) {
-        player->chequeo_fila[i] = false;
-        player->chequeo_columna[i] = false;
-    }
-
-    // Inicializar barcos.
-    inicializar_flota(player);
-    inicializar_cartas(player);
-}
-
-void inicializar_flota(struct player *player) {
-    // Inicializar barcos con diferentes
-    inicializar_barco(&player->ships[0], 5); // 5 cells
-    inicializar_barco(&player->ships[1], 4); // 4 cells
-    inicializar_barco(&player->ships[2], 3); // 3 cells
-    inicializar_barco(&player->ships[3], 3); // 3 cells
-    inicializar_barco(&player->ships[4], 2); // 2 cells
-}
-
-void inicializar_cartas(struct player *player) {
-    // Inicializar cartas con sus IDs, nombres, probabilidades y descripciones
-    for (int i = 0; i < NUM_CARTAS; i++) {
-        player->cartas[i].id = i + 1;
-
-        switch (i + 1) {
-            case 1:
-                strcpy(player->cartas[i].nombre, "Dispara 1 tiro");
-                strcpy(player->cartas[i].descripcion, "Inserta coordenadas donde desees disparar.");
-                player->cartas[i].peso = 7;
-                break;
-            case 2:
-                strcpy(player->cartas[i].nombre, "Dispara 2 tiros");
-                strcpy(player->cartas[i].descripcion, "Inserta coordenadas donde desees disparar. Hazlo de nuevo.");
-                player->cartas[i].peso = 5;
-                break;
-            case 3:
-                strcpy(player->cartas[i].nombre, "Dispara 3 tiros");
-                strcpy(player->cartas[i].descripcion, "Inserta coordenadas donde desees disparar. Hazlo dos veces mas.");
-                player->cartas[i].peso = 2;
-                break;
-            case 4:
-                strcpy(player->cartas[i].nombre, "Bombardea una fila");
-                strcpy(player->cartas[i].descripcion, "Si tienes tu buque de 4 casillas a flote, elige un numero y bombardea esa fila entera.");
-                player->cartas[i].peso = 1;
-                break;
-            case 5:
-                strcpy(player->cartas[i].nombre, "Bombardea una columna");
-                strcpy(player->cartas[i].descripcion, "Si tienes tu buque de 5 casillas a flote, elige una letra y bombardea esa columna entera.");
-                player->cartas[i].peso = 1;
-                break;
-            case 6:
-                strcpy(player->cartas[i].nombre, "Revela");
-                strcpy(player->cartas[i].descripcion, "Tu equipo de inteligencia logro descifrar la ubicacion de una parte de un barco.");
-                player->cartas[i].peso = 1;
-                break;
-            case 7:
-                strcpy(player->cartas[i].nombre, "Chequeo fila");
-                strcpy(player->cartas[i].descripcion, "Tu equipo logro activar el sonar. Elige un numero y podras ver el numero de coordenadas en esa fila.");
-                player->cartas[i].peso = 1;
-                break;
-            case 8:
-                strcpy(player->cartas[i].nombre, "Chequeo columna");
-                strcpy(player->cartas[i].descripcion, "Tu equipo logro activar el sonar. Elige una letra y podras ver el numero de coordenadas en esa columna.");
-                player->cartas[i].peso = 1;
-                break;
-            case 9:
-                strcpy(player->cartas[i].nombre, "Salvo");
-                strcpy(player->cartas[i].descripcion, "Esta carta activa el modo Salvo. Dispara los mismos tiros que tengas en flota.");
-                player->cartas[i].peso = 1;
-                break;
-            case 10:
-                strcpy(player->cartas[i].nombre, "Torre de ventaja");
-                strcpy(player->cartas[i].descripcion, "Acumula 4 tarjetas como esta para hundir instantaneamente los barcos.");
-                player->cartas[i].peso = 4;
-                break;
-            case 11:
-                strcpy(player->cartas[i].nombre, "Tira y toma");
-                strcpy(player->cartas[i].descripcion, "Inserta coordenadas donde desees disparar y vuelve a generar una carta.");
-                player->cartas[i].peso = 1;
-                break;
-            case 12:
-                strcpy(player->cartas[i].nombre, "Mover hacia adelante");
-                strcpy(player->cartas[i].descripcion, "Tu equipo logro obtener materiales para arreglar un motor momentaneamente.");
-                player->cartas[i].peso = 1;
-                break;
-        }
-    }
-}
-
-void calcular_probabilidades(struct player *player) {
-    int suma_pesos = 0;
-    for (int i = 0; i < NUM_CARTAS; i++) {
-        suma_pesos += player->cartas[i].peso;
-    }
-
-    for (int i = 0; i < NUM_CARTAS; i++) {
-        player->cartas[i].probabilidad = (float)player->cartas[i].peso / suma_pesos * 100.0; // Convertir a porcentaje
-    }
-}
-
-void ajustar_probabilidades(struct player *player_1, struct player *player_2) {
-    if (player_1->torres_acumuladas >= 4 || player_2->torres_acumuladas >= 4) {
-        float total_redistribuir = player_1->cartas[9].probabilidad;  // Probabilidad de Torre de ventaja
-        player_1->cartas[9].peso = 0;  // Establecer peso de Torre de ventaja a 0
-
-        calcular_probabilidades(player_1);  // Recalcular probabilidades
-        calcular_probabilidades(player_2);  // Recalcular probabilidades
-
-        // Redistribuir la probabilidad entre las demás cartas proporcionalmente
-        float factor = 1.0 + (total_redistribuir / (100.0 - total_redistribuir));
-        for (int i = 0; i < NUM_CARTAS; i++) {
-            if (i != 9) {  // No ajustar la probabilidad de Torre de ventaja
-                player_1->cartas[i].probabilidad *= factor;
-            }
-        }
-    }
-}
-
-bool validar_coordenadas_en_rango(int fila, int columna) {
-    return (fila >= 0 && fila < BOARD_SIZE && columna >= 0 && columna < BOARD_SIZE);
-}
-
-bool validar_orientacion(int filaInicio, int filaFin, int columnaInicio, int columnaFin) {
-    return (filaInicio == filaFin || columnaInicio == columnaFin);
-}
-
-bool validar_dimension(int filaInicio, int filaFin, int columnaInicio, int columnaFin, int dimension_reuqerida) {
-    int dimension_actual;
-
-    if (filaInicio == filaFin) {
-        dimension_actual = abs(columnaFin - columnaInicio) + 1;
-    } else if(columnaInicio == columnaFin) {
-        dimension_actual = abs(filaFin - filaInicio) + 1;
-        return false; // No es una línea recta
-    }
-    
-    return (dimension_actual == dimension_reuqerida);
-    
-}
-
-bool validar_solapamiento(struct ship *ships, int num_ships_colocados, int filaInicio, int filaFin, int columnaInicio, int columnaFin, int size) {
-    int i, x, y;
-
-    // Recorre todas las posiciones que ocuparía el nuevo barco
-    if (filaInicio == filaFin) {
-        // Horizontal
-        for (i = columnaInicio; (columnaInicio <= columnaFin) ? (i <= columnaFin) : (i >= columnaFin); (columnaInicio <= columnaFin) ? i++ : i--) {
-            x = filaInicio;
-            y = i;
-            // Compara contra todos los barcos ya colocados
-            for (int s = 0; s < num_ships_colocados; s++) {
-                for (int j = 0; j < ships[s].size; j++) {
-                    // Solo compara si la casilla ya fue asignada (no -1)
-                    if (ships[s].status[j][0] == x && ships[s].status[j][1] == y && x != -1 && y != -1) {
-                        return false; // Hay solapamiento
-                    }
-                }
-            }
-        }
-    } else if (columnaInicio == columnaFin) {
-        // Vertical
-        for (i = filaInicio; (filaInicio <= filaFin) ? (i <= filaFin) : (i >= filaFin); (filaInicio <= filaFin) ? i++ : i--) {
-            x = i;
-            y = columnaInicio;
-            for (int s = 0; s < num_ships_colocados; s++) {
-                for (int j = 0; j < ships[s].size; j++) {
-                    if (ships[s].status[j][0] == x && ships[s].status[j][1] == y && x != -1 && y != -1) {
-                        return false; // Hay solapamiento
-                    }
-                }
-            }
-        }
-    }
-    return true; // No hay solapamiento
-}
-
-bool validar_estado_casilla(struct player *player_i, int fila, int columna) {
-    for (int i = 0; i < NUM_SHIPS; i++) {
-        for (int j = 0; j < player_i->ships[i].size; j++) {
-            if (player_i->ships[i].status[j][0] == fila && player_i->ships[i].status[j][1] == columna) {
-                if (player_i->ships[i].status[j][2] == SHIP_BODY_D || player_i->ships[i].status[j][2] == SHIP_STER_D) {
-                    color_txt(ERROR_COLOR);
-                    printf("Ya disparaste en"); color_txt(DEFAULT_COLOR); printf(" %d,%c!\n", fila + 1, columna + 'A');
-                    return false; // Ya disparado
-                }
-                return true; // Casilla válida para disparar
-            }
-        }
-    }
-    color_txt(ERROR_COLOR);
-    printf("Disparo fallido"); color_txt(DEFAULT_COLOR); printf(" en %d,%c! Disparaste al", fila + 1, columna + 'A'); color_txt(WATER_COLOR); printf(" agua.\n");
-    color_txt(DEFAULT_COLOR);
-    return false; // La casilla no es parte de un barco (agua)
-}
-
-void colocar_barco_en_tablero(struct ship *ship_i, int filaInicio, int filaFin, int columnaInicio, int columnaFin) {
-    int i, idx = 0;
-
-    // Solo almacena la información en ship_i->status
-    switch (ship_i->direction) {
-        case 'E':
-            for (i = columnaInicio; i <= columnaFin; i++, idx++) {
-                ship_i->status[idx][0] = filaInicio;
-                ship_i->status[idx][1] = i;
-                ship_i->status[idx][2] = (idx == 0) ? SHIP_STER : SHIP_BODY;
-            }
-            break;
-        case 'O':
-            for (i = columnaInicio; i >= columnaFin; i--, idx++) {
-                ship_i->status[idx][0] = filaInicio;
-                ship_i->status[idx][1] = i;
-                ship_i->status[idx][2] = (idx == 0) ? SHIP_STER : SHIP_BODY;
-            }
-            break;
-        case 'S':
-            for (i = filaInicio; i <= filaFin; i++, idx++) {
-                ship_i->status[idx][0] = i;
-                ship_i->status[idx][1] = columnaInicio;
-                ship_i->status[idx][2] = (idx == 0) ? SHIP_STER : SHIP_BODY;
-            }
-            break;
-        case 'N':
-            for (i = filaInicio; i >= filaFin; i--, idx++) {
-                ship_i->status[idx][0] = i;
-                ship_i->status[idx][1] = columnaInicio;
-                ship_i->status[idx][2] = (idx == 0) ? SHIP_STER : SHIP_BODY;
-            }
-            break;
-    }
-}
-
-
-bool procesar_coordenadas(struct ship *ship_i, int filaInicio, int filaFin, int columnaInicio, int columnaFin, struct player *player_i) {
-    // Validar orientación (horizontal o vertical)
-    if(!validar_orientacion(filaInicio, filaFin, columnaInicio, columnaFin)) {
-        color_txt(ERROR_COLOR);
-        printf("Las coordenadas no son validas. El barco debe ser horizontal o vertical.\n");
-        color_txt(DEFAULT_COLOR);
-        return false;
-    }
-
-    // Validar que la dimensión del barco sea correcta
-    if(!validar_dimension(filaInicio, filaFin, columnaInicio, columnaFin, ship_i->size)) {
-        color_txt(ERROR_COLOR);
-        printf("Las coordenadas no son validas. El barco debe tener exactamente %d celdas de longitud.\n", ship_i->size);
-        color_txt(DEFAULT_COLOR);
-        return false;
-    }
-
-    // Validar que no haya solapamiento con otros barcos
-    if(!validar_solapamiento(player_i->ships, player_i->placed_ships, filaInicio, filaFin, columnaInicio, columnaFin, ship_i->size)) {
-        color_txt(ERROR_COLOR);
-        printf("Las coordenadas no son validas. Hay solapamiento con otro barco.\n");
-        color_txt(DEFAULT_COLOR);
-        return false;
-    }    
-    return true;
-}
-
-bool validar_movimiento(struct player *player_i, struct ship *ship_i) {
-    int dx = 0, dy = 0;
-    int nx, ny;
-    int s, k;
-    switch(ship_i->direction) {
-        case 'E': dy =  1; break;
-        case 'O': dy = -1; break;
-        case 'N': dx =  1; break;
-        case 'S': dx = -1; break;
-        default: return false;
-    }
-    nx = ship_i->status[0][CC_FILA] + dx;
-    ny = ship_i->status[0][CC_COLUMNA] + dy;
-
-    // Validar rango en la matriz
-    if(nx < 0 || ny < 0 || nx >= BOARD_SIZE || ny >= BOARD_SIZE) {
-        return false;
-    }
-
-    // Validar solapamiento con otro barco
-    for(s = 0; s < NUM_SHIPS; s++){
-        for(k = 0; k < player_i->ships[s].size; k++) {
-            if(player_i->ships[s].status[k][CC_FILA] == nx && player_i->ships[s].status[k][CC_COLUMNA] == ny) {
-                return false;
-            }
-        }
-    }
-
-    // Validar salud del barco
-    for(int p = 0; p < ship_i->size; p++) {
-        if(ship_i->status[p][CC_STATUS] == SHIP_BODY_D || ship_i->status[p][CC_STATUS] == SHIP_STER_D) {
-            return false;
-        }
-    }
-    return true;
-}
-
-void decidir_primer_turno(struct player *p1, struct player *p2) {
-    int primer_turno = (rand() % 2) + 1;
-    printf("Decidiendo quien sera el primer jugador de forma aleatoria...\n");
-    Sleep(1000);
-
-    if (primer_turno == 1) {
-        p1->turno = 1;
-        p2->turno = 2;
-        color_txt(INFO_COLOR); printf("%s ", p1->name); color_txt(DEFAULT_COLOR); printf("ha sido elegido para comenzar la partida\n");
-        color_txt(INFO_COLOR); printf("%s ", p2->name); color_txt(DEFAULT_COLOR); printf("sera el segundo en jugar\n");
-    } else {
-        p1->turno = 2;
-        p2->turno = 1;
-        color_txt(INFO_COLOR); printf("%s ", p2->name); color_txt(DEFAULT_COLOR); printf("ha sido elegido para comenzar la partida\n");
-        color_txt(INFO_COLOR); printf("%s ", p1->name); color_txt(DEFAULT_COLOR); printf("sera el segundo en jugar\n");
-    }
-    Sleep(1000);
-    enter_continuar();
-    limpiar_pantalla();
-}
-
-int obtener_id_aleatoria(struct player *player_i) {
-    // Recalcular probabilidades antes de sacar una carta
-    calcular_probabilidades(player_i);
-
-    float numero_rand = (float)(rand() % 10000) / 100.0f; // Número aleatorio entre 0 y 100
-    float acumulado = 0.0f;
-
-    for (int i = 0; i < NUM_CARTAS; i++) {
-        acumulado += player_i->cartas[i].probabilidad;
-        if (numero_rand < acumulado) {
-            return i;
-        }
-    }
-    // Si no cayó en ningún rango, devuelve la última carta
-    return NUM_CARTAS - 1;
-}
-
-void sacar_carta(struct player *player_i, struct player *enemy_i) {
-    int carta_id = obtener_id_aleatoria(player_i);
-
-    limpiar_pantalla();
-    mostrar_turno_y_tablero(player_i, enemy_i);
-    mostrar_info_carta(&player_i->cartas[carta_id]);
-    switch (carta_id) {
-    case 0:
-        funcion_carta_1(player_i, enemy_i, carta_id);
-        break;
-    case 1:
-        funcion_carta_2(player_i, enemy_i, carta_id);
-        break;
-    case 2:
-        funcion_carta_3(player_i, enemy_i, carta_id);
-    case 3: case 4: case 6: case 7:
-        capturar_fila_columna(carta_id, player_i, enemy_i);
-        if (carta_id == 6) {
-            printf("La fila ha sido revelada.\n");
-        } else if (carta_id == 7) {
-            printf("La columna ha sido revelada.\n");
-        }
-        mostrar_turno_y_tablero(player_i, enemy_i);
-        break;
-    case 5:
-        revela(enemy_i, player_i);
-        break;
-    case 8:
-        activar_salvo(player_i);
-        printf("\n¡Modo Salvo activado!\n");
-        printf("Durante este turno NO disparas. En tu próximo turno, podrás disparar múltiples veces.\n");
-        printf("Presiona enter para terminar el turno.\n");
-        enter_continuar();
-        limpiar_pantalla();
-        break;
-    case 9:
-        if(player_i->torres_acumuladas < MAX_ID_10) {
-            player_i->torres_acumuladas++;
-            printf("Has acumulado una torre de ventaja. Acumula 4 para hundir instantaneamente los barcos enemigos.\n");
-            // Reducir el peso de la carta Torre de ventaja
-            if (player_i->cartas[9].peso > 0) player_i->cartas[9].peso--;
-            ajustar_probabilidades(player_i, enemy_i);
-
-        } else {
-            torre_ventaja(player_i);
-        }
-        break;
-    case 10:
-        tira_toma(player_i, enemy_i);
-        break;
-    case 11:
-        solicitar_barco(player_i, enemy_i);
-        break;
-    }
-
-    if (carta_id != 9 && carta_id != 11) {
-        enter_continuar();
-        limpiar_pantalla();
-    }
-}
-
-void funcion_carta_1(struct player *player_i, struct player *enemy_i, int carta_id) {
-    int disparos = player_i->salvo ? (NUM_SHIPS - enemy_i->sunked_ships) : 1;
-    for (int i = 0; i < disparos; i++) {
-        if (i == 0) {
-            printf("Dispara una vez.\n");
-        } else {
-            printf("Dispara de nuevo.\n");
-        }
-        Sleep(1000);
-        mostrar_turno_y_tablero(player_i, enemy_i);
-        capturar_coordenada(player_i, enemy_i);
-        limpiar_pantalla();
-    }
-    enter_continuar();
-    limpiar_pantalla();
-}
-
-void funcion_carta_2(struct player *player_i, struct player *enemy_i, int carta_id) {
-    printf("Dispara una vez.\n");
-    Sleep(1000);
-    mostrar_turno_y_tablero(player_i, enemy_i);
-    mostrar_info_carta(&player_i->cartas[carta_id]);
-    capturar_coordenada(player_i, enemy_i);
-    Sleep(1000);
-    limpiar_pantalla();
-    printf("Dispara de nuevo.\n");
-    Sleep(1000);
-    mostrar_turno_y_tablero(player_i, enemy_i);
-    capturar_coordenada(player_i, enemy_i);
-}
-
-void funcion_carta_3(struct player *player_i, struct player *enemy_i, int carta_id) {
-    for (int i = 0; i < 3; i++) {
-        if (i == 0) {
-            printf("Dispara una vez.\n");
-        } else if (i == 1) {
-            printf("Dispara de nuevo.\n");
-        } else if (i == 2) {
-            printf("Dispara una vez mas.\n");
-        }
-        Sleep(1000);
-        mostrar_turno_y_tablero(player_i, enemy_i);
-        capturar_coordenada(player_i, enemy_i);
-        limpiar_pantalla();
-    }
-    enter_continuar();
-}
-
-void limpiar_buffer_entrada() {
-    int c;
-    while ((c = getchar()) != '\n' && c != EOF);
-}
-
-void liberar_status(struct ship *barco) {
-    for (int i = 0; i < barco->size; i++) {
-        free(barco->status[i]);
-    }
-    free(barco->status);
-    barco->status = NULL; // Evitar puntero colgante
-}
-
-void liberar_flota(struct player *player) {
-    for (int i = 0; i < NUM_SHIPS; i++) {
-        liberar_status(&player->ships[i]);
-    }
-}
\ No newline at end of file
diff --git a/codigo_fuente/bs_logic.h b/codigo_fuente/bs_logic.h
deleted file mode 100644
index 0cf8104..0000000
--- a/codigo_fuente/bs_logic.h
+++ /dev/null
@@ -1,55 +0,0 @@
-#ifndef BS_LOGIC_H
-#define BS_LOGIC_H
-
-#include <stdbool.h> // Incluye definiciones de tipo booleano estándar
-#include "bs_common.h" // Incluye definiciones comunes
-
-// Function prototypes
-void inicializar_barco(struct ship *barco, int size);
-
-void hundido(struct player *enemy_i, struct player *player_i); // Verifica si un barco está hundido.
-
-void inicializar_jugador(struct player *player); // Inicializar jugadores.
-
-void inicializar_flota(struct player *player); // Inicializa la flota de un jugador.
-
-void inicializar_cartas(struct player *player); // Inicializa las cartas de un jugador.
-
-void calcular_probabilidades(struct player *player); // Calcula las probabilidades de las cartas.
-
-void ajustar_probabilidades(struct player *player_1, struct player *player_2); // Ajusta las probabilidades de las cartas.
-
-bool validar_coordenadas_en_rango(int fila, int columna); // Funciones de validacion de colocacion de barcos
-
-bool validar_orientacion(int filaInicio, int filaFin, int columnaInicio, int columnaFin);
-
-bool validar_dimension(int filaInicio, int filaFin, int columnaInicio, int columnaFin, int dimension_reuqerida);
-
-bool validar_solapamiento(struct ship *ships, int num_ships_colocados, int filaInicio, int filaFin, int columnaInicio, int columnaFin, int size);
-
-bool validar_estado_casilla(struct player *player_i, int fila, int columna);
-
-void colocar_barco_en_tablero(struct ship *ship_i, int filaInicio, int filaFin, int columnaInicio, int columnaFin);
-
-bool procesar_coordenadas(struct ship *ship_i, int filaInicio, int filaFin, int columnaInicio, int columnaFin, struct player *player_i);
-
-bool validar_movimiento(struct player *player_i, struct ship *ship_i);
-
-void decidir_primer_turno(struct player *p1, struct player *p2);
-
-int obtener_id_aleatoria(struct player *player_i); // Función para obtener un ID de carta aleatorio
-
-void sacar_carta(struct player *player_i, struct player *enemy_i); // Función para sacar una carta
-
-void funcion_carta_1(struct player *player_i, struct player *enemy_i, int carta_id);
-
-void funcion_carta_2(struct player *player_i, struct player *enemy_i, int carta_id);
-
-void funcion_carta_3(struct player *player_i, struct player *enemy_i, int carta_id);
-
-void limpiar_buffer_entrada(); // Función para limpiar el buffer de entrada
-
-void liberar_status(struct ship *barco);
-
-void liberar_flota(struct player *player);
-#endif // BS_LOGIC_H
\ No newline at end of file
diff --git a/codigo_fuente/bs_ui.c b/codigo_fuente/bs_ui.c
deleted file mode 100644
index dee9af6..0000000
--- a/codigo_fuente/bs_ui.c
+++ /dev/null
@@ -1,854 +0,0 @@
-#include "bs_ui.h" // libreria para poder usar funciones de UI.
-#include "bs_console_utils.h" // libreria para poder usar la funcion limpiar y cambio de color.
-#include "bs_logic.h" // libreria para poder usar funciones de logica.
-#include "bs_efectos_cartas.h" // libreria para poder usar funciones de efectos de cartas.
-#include <windows.h> // libreria para poder usar la funcion Sleep.
-#include <string.h> // libreria para poder usar la funcion strcspn.
-#include <ctype.h> // libreria para poder usar la funcion toupper.
-#include <time.h> // libreria para poder usar la funcion time.
-#include <stdio.h> // libreria para funciones de entrada/salida como stdin.
-
-void pantalla_bienvenida() {
-    // Logo para la pantalla de inicio.
-	printf(" _______  _______  _______  _______  ___      ___      _______    __    _  _______  __   __  _______  ___     \n");
-	printf("|  _    ||   _   ||       ||   _   ||   |    |   |    |   _   |  |  |  | ||   _   ||  | |  ||   _   ||   |    \n");
-	printf("| |_|   ||  |_|  ||_     _||  |_|  ||   |    |   |    |  |_|  |  |   |_| ||  |_|  ||  |_|  ||  |_|  ||   |    \n");
-	printf("|       ||       |  |   |  |       ||   |    |   |    |       |  |       ||       ||       ||       ||   |    \n");
-	printf("|  _   | |       |  |   |  |       ||   |___ |   |___ |       |  |  _    ||       ||       ||       ||   |___ \n");
-	printf("| |_|   ||   _   |  |   |  |   _   ||       ||       ||   _   |  | | |   ||   _   | |     | |   _   ||       | \n");
-	printf("|_______||__| |__|  |___|  |__| |__||_______||_______||__| |__|  |_|  |__||__| |__|  |___|  |__| |__||_______| \n");
-	
-	enter_continuar(); // Pausa antes de continuar.
-	limpiar_pantalla(); // Limpiar la pantalla después de mostrar el logo.
-}
-
-void menu_principal() {
-    char opc = ' ';
-
-	// Menu de opciones inicial.
-	do{
-		printf("Presione la tecla correspondiente a su opcion.\n");
-		printf("Opciones:\n");
-		printf("[A]: Iniciar partida\n");
-        printf("[B]: Ver reglas.\n");
-        printf("[C]: Salir\n");
-		scanf(" %c", &opc);
-        opc = toupper(opc); // Convertir a mayúscula para evitar problemas de comparación.
-		switch(opc) {
-		    // Caso en el que el usuario quiere iniciar partida.
-            case 'A':
-                limpiar_pantalla(); // Limpiar la pantalla antes de iniciar la partida.
-                partida();
-                break;
-            // caso en el que el usuario quiere leer las reglas.
-            case 'B':
-                reglas();
-                break;
-            // Caso en el que el usuario quiere salir del programa (se especifica con un "case" porque sino el programa imprime "tecla inv�lida" cuando se presiona la c).
-            case 'C':
-                printf("Gracias por haber usado el programa :)");
-                break;
-            default:
-                puts("¡Tecla invalida!");
-                Sleep(1000); // funcion para tener demora en la ejecucion de la limpieza de la terminal.
-                limpiar_pantalla(); // Limpiar la pantalla.
-                break;
-            }
-	}while(opc != 'c' && opc != 'C');
-}
-
-void menu_por_turno(struct player *player_i, struct player *enemy_i) {
-    srand(time(NULL));
-    char opc = ' ';
-    do {
-        // Menu de opciones por turno.
-    printf("Elija la opcion que desea realizar:\n");
-    printf("[A]: Sacar carta\n");
-    printf("[B]: Reporte de flota\n");
-    printf("[C]: Reporte de barcos enemigos\n");
-
-    scanf(" %c", &opc);
-    limpiar_buffer_entrada(); // Limpiar el buffer de entrada antes de procesar la opción.
-    opc = toupper(opc); // Convertir a mayúscula para evitar problemas de comparación.
-    switch(opc) {
-        case 'A':
-            sacar_carta(player_i, enemy_i);
-            opc = 'Z'; // Cambiar la opcion para salir del menu.
-            break;
-        case 'B':
-            imprimirReporteBarcos(player_i, enemy_i);
-            break;
-        case 'C':
-            // Logica reporte barcos enemigos
-            break;
-        default:
-            color_txt(ERROR_COLOR);
-            printf("¡Tecla invalida!\n");
-            color_txt(DEFAULT_COLOR);
-    }
-    }while(opc != 'Z' && opc != 'z');
-    limpiar_pantalla(); // Limpiar la pantalla después de salir del menú.
-}
-
-void solicitar_nombre(struct player *player) {
-    do {
-        printf("Introduce el nombre del jugador (max 20 caracteres): ");
-        if (fgets(player->name, sizeof(player->name), stdin) == NULL) {
-            color_txt(ERROR_COLOR);
-            printf("Error de entrada. Intenta de nuevo.\n");
-            color_txt(DEFAULT_COLOR);
-            continue;
-        }
-
-        // Si no hay salto de línea, limpiar el buffer y repetir
-        if (strchr(player->name, '\n') == NULL) {
-            int c;
-            while ((c = getchar()) != '\n' && c != EOF); // Limpiar buffer completamente
-            color_txt(ERROR_COLOR);
-            printf("El nombre no puede tener mas de 20 caracteres. Intenta de nuevo.\n");
-            color_txt(DEFAULT_COLOR);
-            continue;
-        }
-
-        // Eliminar salto de línea
-        player->name[strcspn(player->name, "\n")] = '\0';
-
-        // Validar longitud
-        size_t len = strlen(player->name);
-        if (len == 0) {
-            color_txt(ERROR_COLOR);
-            printf("El nombre no puede estar vacio. Intenta de nuevo.\n");
-            color_txt(DEFAULT_COLOR);
-            continue;
-        }
-        if (len > 20) {
-            color_txt(ERROR_COLOR);
-            printf("El nombre no puede tener mas de 20 caracteres. Intenta de nuevo.\n");
-            color_txt(DEFAULT_COLOR);
-            continue;
-        }
-
-        // Si pasa todas las validaciones, salir del ciclo
-        break;
-    } while (1);
-}
-
-void partida() {
-    struct player player1, player2;
-
-    limpiar_buffer_entrada(); // Limpiar el buffer de entrada antes de solicitar el nombre.
-    printf("Jugador 1:\n");
-    inicializar_jugador(&player1);
-    limpiar_pantalla(); // Limpiar pantalla despues del primer jugador.
-    printf("Jugador 2:\n");
-    inicializar_jugador(&player2);
-    limpiar_pantalla(); // Limpiar la pantalla después de inicializar jugadores.
-    
-    printf("Jugadores:\n");
-    printf("Jugador 1:"); color_txt(INFO_COLOR); printf(" %s\n",player1.name); color_txt(DEFAULT_COLOR);
-    printf("Jugador 2:"); color_txt(INFO_COLOR); printf(" %s\n",player2.name); color_txt(DEFAULT_COLOR);
-    printf("Presione enter para ");  color_txt(INFO_COLOR); printf(" continuar.\n"); color_txt(DEFAULT_COLOR);
-    getchar(); // Pausa antes de continuar.
-    limpiar_pantalla(); // Limpiar la pantalla después de mostrar los nombres de los jugadores.
-    
-    // Colocar barcos para el jugador 1.
-    colocar_barcos_jugador(&player1); // Colocar barcos para el jugador 1.
-
-    // Colocar barcos para el jugador 2.
-    printf("Ahora es turno de"); color_txt(INFO_COLOR); printf(" %s\n", player2.name); color_txt(DEFAULT_COLOR);
-    enter_continuar(); // Pausa antes de continuar.
-
-    colocar_barcos_jugador(&player2);
-
-    // Elegir aleatoriamente quién inicia
-    decidir_primer_turno(&player1, &player2);
-
-    struct player *jugador_actual, *jugador_enemigo;
-    if(player1.turno == 1) {
-        jugador_actual = &player1;
-        jugador_enemigo = &player2;
-    } else {
-        jugador_actual = &player2;
-        jugador_enemigo = &player1;
-    }
-
-    do {
-        printf("Turno de"); color_txt(INFO_COLOR); printf(" %s\n", jugador_actual->name); color_txt(DEFAULT_COLOR);
-        imprimirTableroGuerra(jugador_enemigo, jugador_actual);
-        menu_por_turno(jugador_actual, jugador_enemigo);
-    
-        // Mensaje de cambio de turno
-        printf("Ahora es turno de %s\n", jugador_enemigo->name);
-        enter_continuar();
-        limpiar_pantalla(); // Limpiar la pantalla después de mostrar el turno.
-
-        // Alternar punteros (esto es lo que realmente cambia el turno)
-        struct player *temp = jugador_actual;
-        jugador_actual = jugador_enemigo;
-        jugador_enemigo = temp;
-    
-    } while(jugador_actual->enemy_hit_parts < VICTORYCONDITION && jugador_enemigo->enemy_hit_parts < VICTORYCONDITION);
-
-    // Mensaje de victoria
-    if(jugador_actual->enemy_hit_parts >= VICTORYCONDITION) {
-            printf("%s ha ganado!\n", jugador_actual->name);
-        } else if(jugador_enemigo->enemy_hit_parts >= VICTORYCONDITION) {
-            printf("%s ha ganado!\n", jugador_enemigo->name);
-        }
-    liberar_flota(&player1); // Liberar memoria de la flota del jugador 1.
-	liberar_flota(&player2); // Liberar memoria de la flota del jugador 2.
-
-}
-
-void capturar_coordenada(struct player *player_i, struct player *enemy_i) {
-    int fila, columna;
-    char columna_c;
-    bool coordenadas_validas = false;
-
-    while (!coordenadas_validas) {
-        printf("Ingrese las coordenadas (ejemplo: 1 A): ");
-        if (scanf(" %d %c", &fila, &columna_c) != 2) {
-            color_txt(ERROR_COLOR);
-            printf("Entrada invalida. Asegurese de ingresar un numero seguido de una letra. Intente de nuevo.\n");
-            color_txt(DEFAULT_COLOR);
-            limpiar_buffer_entrada();
-            continue;
-        }
-
-        fila--; // Convertir a base 0
-        columna_c = toupper(columna_c);
-
-        if (columna_c >= 'A' && columna_c <= 'J') {
-            columna = columna_c - 'A';
-        } else {
-            color_txt(ERROR_COLOR);
-            printf("Columna invalida. Asegurese de ingresar una letra entre A y J. Intente de nuevo.\n");
-            color_txt(DEFAULT_COLOR);
-            limpiar_buffer_entrada();
-            continue;
-        }
-
-        if (!validar_coordenadas_en_rango(fila, columna)) {
-            color_txt(ERROR_COLOR);
-            printf("Coordenadas fuera de rango. Intente de nuevo.\n");
-            color_txt(DEFAULT_COLOR);
-            limpiar_buffer_entrada();
-            continue;
-        }
-
-        // Validar estado de la casilla antes de disparar
-        if (!validar_estado_casilla(enemy_i, fila, columna)) {
-            color_txt(ERROR_COLOR);
-            printf("Ya has disparado a esa casilla. Elige otra.\n");
-            color_txt(DEFAULT_COLOR);
-            limpiar_buffer_entrada();
-            continue;
-        }
-
-        coordenadas_validas = true;
-    }
-    // Llama a la función de disparo con fila y columna
-    disparar(player_i, enemy_i, fila, columna);
-    mostrar_turno_y_tablero(player_i, enemy_i); // Mostrar el tablero después de disparar.
-    printf("Disparaste en %d,%c!\n", fila + 1, columna_c);
-    enter_continuar(); // Pausa antes de continuar.
-    limpiar_pantalla(); // Limpiar la pantalla después de disparar.
-}
-
-void capturar_fila_columna(int carta_id, struct player *player_i, struct player *enemy_i) {
-    char columna_c;
-    int columna, fila;
-
-    // Capturar fila o columna dependiendo de la carta
-    if (carta_id == 4 || carta_id == 7) {
-        // Capturar fila
-        do {
-            printf("Ingrese la fila a capturar (1-%d): ", BOARD_SIZE);
-            if (scanf("%d", &fila) != 1) {
-                color_txt(ERROR_COLOR);
-                printf("Entrada invalida. Debe ser un numero.\n");
-                color_txt(DEFAULT_COLOR);
-                limpiar_buffer_entrada();
-                fila = -1;
-                continue;
-            }
-            if (fila < 1 || fila > BOARD_SIZE) {
-                color_txt(ERROR_COLOR);
-                printf("Fila invalida. Debe estar entre 1 y %d.\n", BOARD_SIZE);
-                color_txt(DEFAULT_COLOR);
-            }
-        } while (fila < 1 || fila > BOARD_SIZE);
-    } else if (carta_id == 5 || carta_id == 8) {
-        // Capturar columna
-        do {
-            printf("Ingrese la columna a capturar (A-J): ");
-            if (scanf(" %c", &columna_c) != 1) {
-                color_txt(ERROR_COLOR);
-                printf("Entrada invalida. Debe ser una letra.\n");
-                color_txt(DEFAULT_COLOR);
-                limpiar_buffer_entrada();
-                columna = -1;
-                continue;
-            }
-            columna_c = toupper(columna_c);
-            columna = columna_c - 'A';
-            if (columna < 0 || columna > 9) {
-                color_txt(ERROR_COLOR);
-                printf("Columna invalida. Debe estar entre A y J.\n");
-                color_txt(DEFAULT_COLOR);
-            }
-        } while (columna < 0 || columna > 9);
-    }
-
-    switch (carta_id) {
-        case 4:
-            // Bombardea fila
-            bombardea_fila(player_i, enemy_i, fila);
-            break;
-        case 5:
-            // Bombardea columna
-            bombardea_columna(player_i, enemy_i, columna);
-            break;
-        case 7:
-            // Chequeo fila
-            chequeo_fila(player_i, enemy_i, fila);
-            break;
-        case 8:
-            // Chequeo columna
-            chequeo_columna(player_i, enemy_i, columna);
-            break;
-        default:
-            break;
-    }
-    imprimirTableroGuerra(enemy_i, player_i); // Imprimir el tablero del enemigo después de la acción.
-}
-
-void imprimirTablero(struct player *player_i) {
-    int anchoTablero, relleno, consolaAncho;
-    char caracter;
-    int i, j, s, k, estado;
-    CONSOLE_SCREEN_BUFFER_INFO csbi;
-    
-    // Obtener ancho de consola
-    consolaAncho = 80; //Por defecto si no es posible
-    if(GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &csbi)) {
-        consolaAncho = csbi.srWindow.Right - csbi.srWindow.Left + 1;
-    }
-
-    // Calculando relleno para centrar
-    anchoTablero = BOARD_SIZE * 2 + 4; // Dos caracteres por columna + 4 para las filas de nuemros y espaciado
-    relleno = (consolaAncho - anchoTablero) / 2;
-
-    // Encabezado de columnas (A B C D E F G H I J)
-    printf("%*s", relleno,""); // Imprime relleno con espacios para centrar
-    printf("   ");
-    for (caracter = 'A'; caracter <= 'J'; caracter++) {
-        printf("%c ", caracter);
-    }
-    printf("\n");
-
-    // Dibujar cada fila
-    for (i = 0; i < BOARD_SIZE; i++) {
-        printf("%*s%.2d ", relleno,"", i + 1); // // Encabezado de filas(1 2 3 4 5 6 7 8 9 10) con relleno para centrar
-        for (j = 0; j < BOARD_SIZE; j++) {
-            estado = WATER; // Por defecto el estado es agua
-            for (s = 0; s < NUM_SHIPS && estado == WATER; s++) {
-                for (k = 0; k < player_i->ships[s].size; k++) {
-                    if (player_i->ships[s].status[k][0] == i && player_i->ships[s].status[k][1] == j) //Buscando coincidencias en las coordenadas guardadas por los barcos y la matriz impresa
-                    {
-                        estado = player_i->ships[s].status[k][2];
-                        break;
-                    }
-                    
-                }
-            }
-            switch (estado) {
-                case SHIP_STER:
-                    color_txt(SHIP_COLOR);
-                    printf("%c ", STER_PRINT);
-                    color_txt(DEFAULT_COLOR);
-                    break;
-                case SHIP_BODY:
-                    color_txt(SHIP_COLOR);
-                    printf("%c ", BODY_PRINT);
-                    color_txt(DEFAULT_COLOR);
-                    break;
-                case SHIP_STER_D:
-                    color_txt(ERROR_COLOR);
-                    printf("%c ", STER_PRINT);
-                    color_txt(DEFAULT_COLOR);
-                    break;
-                case SHIP_BODY_D:
-                    color_txt(ERROR_COLOR);
-                    printf("%c ", BODY_PRINT);
-                    color_txt(DEFAULT_COLOR);
-                    break;
-                default:
-                    color_txt(WATER_COLOR);
-                    printf("%c ", WATER_PRINT);
-                    color_txt(DEFAULT_COLOR);
-                    break;
-            }
-        }
-        printf("\n");
-    }
-}
-
-void imprimirTableroGuerra(struct player *enemy_i, struct player *player_i) {
-    int anchoTablero, relleno, consolaAncho;
-    char caracter;
-    int i, j, s, k, estado;
-    bool hay_chequeo_columna = false;
-    int chequeo_fila[BOARD_SIZE] = {0};
-    int chequeo_columna[BOARD_SIZE] = {0};
-    CONSOLE_SCREEN_BUFFER_INFO csbi;
-
-    // Inicializar chequeo_fila y chequeo_columna y contadores
-    for (i = 0; i < BOARD_SIZE; i++) {
-        // Chequeo de fila: contar solo si está activado
-        if (player_i->chequeo_fila[i]) {
-            for (j = 0; j < BOARD_SIZE; j++) {
-                for (s = 0; s < NUM_SHIPS; s++) {
-                    for (k = 0; k < enemy_i->ships[s].size; k++) {
-                        if (enemy_i->ships[s].status[k][0] == i && enemy_i->ships[s].status[k][1] == j && (enemy_i->ships[s].status[k][2] == SHIP_BODY || enemy_i->ships[s].status[k][2] == SHIP_STER)) {
-                            chequeo_fila[i]++;
-                        }
-                    }
-                }
-            }
-        }
-        // Chequeo de columna: contar solo si está activado
-        if (player_i->chequeo_columna[i]) {
-            for (j = 0; j < BOARD_SIZE; j++) {
-                for (s = 0; s < NUM_SHIPS; s++) {
-                    for (k = 0; k < enemy_i->ships[s].size; k++) {
-                        if (enemy_i->ships[s].status[k][1] == i && enemy_i->ships[s].status[k][0] == j && (enemy_i->ships[s].status[k][2] == SHIP_BODY || enemy_i->ships[s].status[k][2] == SHIP_STER)) {
-                            chequeo_columna[i]++;
-                        }
-                    }
-               }
-           }
-       }
-    }
-
-    // Obtener ancho de consola
-    consolaAncho = 80; //Por defecto si no es posible
-    if(GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &csbi)) {
-        consolaAncho = csbi.srWindow.Right - csbi.srWindow.Left + 1;
-    }
-
-    // Calculando relleno para centrar
-    anchoTablero = BOARD_SIZE * 2 + 4; // Dos caracteres por columna + 4 para las filas de nuemros y espaciado
-    relleno = (consolaAncho - anchoTablero) / 2;
-
-    // Encabezado de columnas (A B C D E F G H I J)
-    printf("%*s", relleno,""); // Imprime relleno con espacios para centrar
-    printf("   ");
-    for (caracter = 'A'; caracter <= 'J'; caracter++) {
-        printf("%c ", caracter);
-    }
-    printf("\n");
-
-    // Dibujar cada fila
-    for (i = 0; i < BOARD_SIZE; i++) {
-        printf("%*s%.2d ", relleno,"", i + 1); // Encabezado de filas
-        for (j = 0; j < BOARD_SIZE; j++) {
-            estado = WATER; // Por defecto el estado es agua
-            for (s = 0; s < NUM_SHIPS && estado == WATER; s++) {
-                for (k = 0; k < enemy_i->ships[s].size; k++) {
-                    if (enemy_i->ships[s].status[k][0] == i && enemy_i->ships[s].status[k][1] == j) {
-                        // Solo mostrar si está dañado (status == SHIP_BODY+2 o SHIP_STER+2)
-                        if (enemy_i->ships[s].status[k][2] == SHIP_BODY_D) {
-                            estado = SHIP_BODY_D;
-                        } else if (enemy_i->ships[s].status[k][2] == SHIP_STER_D) {
-                            estado = SHIP_STER_D;
-                        }
-                        break;
-                    }
-                }
-            }
-            switch (estado) {
-                case SHIP_STER_D:
-                    color_txt(ERROR_COLOR);
-                    printf("%c ", STER_PRINT);
-                    color_txt(DEFAULT_COLOR);
-                    break;
-                case SHIP_BODY_D:
-                    color_txt(ERROR_COLOR);
-                    printf("%c ", BODY_PRINT);
-                    color_txt(DEFAULT_COLOR);
-                    break;
-                default:
-                    color_txt(WATER_COLOR);
-                    printf("%c ", WATER_PRINT);
-                    color_txt(DEFAULT_COLOR);
-                    break;
-            }
-        }
-        // Mostrar chequeo de fila al final de la fila solo si está activado
-        if (player_i->chequeo_fila[i]) {
-            color_txt(SUCCESS_COLOR);
-            printf(" %d", chequeo_fila[i]);
-            color_txt(DEFAULT_COLOR);
-        }
-        printf("\n");
-    }
-
-    // Mostrar chequeo de columna (una sola línea debajo del tablero)
-    for (i = 0; i < BOARD_SIZE; i++) {
-        if (player_i->chequeo_columna[i]) {
-            hay_chequeo_columna = true;
-            break;
-        }
-    }
-    if (hay_chequeo_columna) {
-        printf("%*s   ", relleno, "");
-        for (j = 0; j < BOARD_SIZE; j++) {
-            if (player_i->chequeo_columna[j]) {
-                color_txt(SUCCESS_COLOR);
-                printf("%d ", chequeo_columna[j]);
-                color_txt(DEFAULT_COLOR);
-            } else {
-                printf("  ");
-            }
-        }
-        printf("\n");
-    }
-}
-
-void imprimirReporteBarcos(struct player *player_i, struct player *enemy_i) {
-    int i, k;
-    int dimension_maxima = 0;
-    int ancho_col = 12; // Ancho fijo para cada barco
-
-    limpiar_pantalla();
-    printf("Turno de"); color_txt(INFO_COLOR); printf(" %s\n", player_i->name); color_txt(DEFAULT_COLOR);
-    imprimirTableroGuerra(enemy_i, player_i);
-    printf("\n");
-    printf("Reporte de barcos:\n");
-
-    // Encontrar el tamaño máximo de los barcos
-    for (i = 0; i < NUM_SHIPS; i++) {
-        if (player_i->ships[i].size > dimension_maxima) {
-            dimension_maxima = player_i->ships[i].size;
-        }
-    }
-
-    // Encabezado
-    for (i = 0; i < NUM_SHIPS; i++) {
-        printf("%*sBote %02d", ancho_col / 2 - 4, "", i + 1);
-        printf("%*s", ancho_col - (ancho_col / 2 + 4), "");
-    }
-    printf("\n");
-
-    // Dibujo de proa (/'\)
-    for (i = 0; i < NUM_SHIPS; i++) {
-        int estado = player_i->ships[i].status[0][2];
-        if (i == 0) printf("%*s", ancho_col - 8, "");
-        estado == SHIP_STER ? color_txt(SHIP_COLOR) : color_txt(ERROR_COLOR);
-        printf("/'\\");
-        color_txt(DEFAULT_COLOR);
-        printf("%*s", ancho_col - 4, "");
-    }
-    printf("\n");
-
-    // Cuerpo del barco
-    for (k = 1; k < dimension_maxima; k++) {
-        for (i = 0; i < NUM_SHIPS; i++) {
-            if (k < player_i->ships[i].size) {
-                int estado = player_i->ships[i].status[k][2];
-                if (i == 0) printf("%*s", ancho_col - 8, "");
-                if (estado == SHIP_BODY) {
-                    color_txt(SHIP_COLOR);
-                    printf("[_]");
-                } else {
-                    color_txt(ERROR_COLOR);
-                    printf("[X]");
-                }
-                color_txt(DEFAULT_COLOR);
-                printf("%*s", ancho_col - 4, "");
-            } else {
-                printf("%*s", ancho_col, "");
-            }
-        }
-    printf("\n");
-    }
-
-    printf("[Z]: Regresar al menu.\n");
-    char opc;
-    scanf(" %c", &opc);
-    opc = toupper(opc);
-    if (opc == 'Z') {
-        limpiar_pantalla();
-        printf("Turno de"); color_txt(INFO_COLOR); printf(" %s\n", player_i->name); color_txt(DEFAULT_COLOR);
-        imprimirTableroGuerra(enemy_i, player_i);
-        printf("\n");
-        menu_por_turno(player_i, enemy_i);
-    } else {
-        color_txt(ERROR_COLOR);
-        printf("¡Tecla invalida!\n");
-        color_txt(DEFAULT_COLOR);
-    }
-}
-
-void ponerBarcos(struct ship *ship_i, struct player *player_i) {
-    int filaInicio, filaFin, columnaInicio, columnaFin;
-    char columnaInicio_c, columnaFin_c;
-    bool coordenadas_validas = false;
-
-    while(!coordenadas_validas) {
-        
-        // Se le pide al usuario que ingrese las coordenadas iniciales y finales del barco.
-        puts("Coordenada inicial del barco (fila 1-10 y columna A-J, separadas por un espacio): ");
-        if (scanf(" %d %c", &filaInicio, &columnaInicio_c) != 2) {
-            color_txt(ERROR_COLOR);
-            printf("Entrada invalida. Asegurese de ingresar un numero seguido de una letra. Intente de nuevo.\n");
-            color_txt(DEFAULT_COLOR);
-            limpiar_buffer_entrada(); // Limpiar el buffer de entrada
-            continue;
-        }
-
-        puts("Coordenadas finales del barco (mismo formato).");
-        if (scanf(" %d %c", &filaFin, &columnaFin_c) != 2) {
-            color_txt(ERROR_COLOR);
-            printf("Entrada invalida. Asegurese de ingresar un numero seguido de una letra. Intente de nuevo.\n");
-            color_txt(DEFAULT_COLOR);
-            limpiar_buffer_entrada(); // Limpiar el buffer de entrada
-            continue;
-        }
-
-        // Ajustar indices de fila(convertir a base 0)
-        filaInicio--; filaFin--;
-        
-        // Transformar la letra de columna a mayúscula si no lo es.
-        columnaInicio_c = toupper(columnaInicio_c);
-        columnaFin_c = toupper(columnaFin_c);
-        
-        // Convertir la letra de columna a un número (A=0, B=1, ..., J=9)
-        if (columnaInicio_c >= 'A' && columnaInicio_c <= 'J') {
-            columnaInicio = columnaInicio_c - 'A';
-        } else {
-            color_txt(ERROR_COLOR);
-            printf("Columna invalida. Asegurese de ingresar una letra entre A y J. Intente de nuevo.\n");
-            color_txt(DEFAULT_COLOR);
-            limpiar_buffer_entrada(); // Limpiar el buffer de entrada
-            continue;
-        }
-        
-        if (columnaFin_c >= 'A' && columnaFin_c <= 'J') {
-            columnaFin = columnaFin_c - 'A';
-        } else {
-            color_txt(ERROR_COLOR);
-            printf("Columna invalida. Asegurese de ingresar una letra entre A y J. Intente de nuevo.\n");
-            color_txt(DEFAULT_COLOR);
-            limpiar_buffer_entrada(); // Limpiar el buffer de entrada
-            continue;
-        }
-
-        //Validaciones
-
-        // Validar que las coordenadas esten dentro del rango permitido.
-        if(!validar_coordenadas_en_rango(filaInicio, columnaInicio) || 
-           !validar_coordenadas_en_rango(filaFin, columnaFin)) {
-            color_txt(ERROR_COLOR);
-            printf("Coordenadas fuera de rango. Asegurese de establecerlas entre 1 y 10 para filas y A-J para columnas. Intente de nuevo.\n");
-            color_txt(DEFAULT_COLOR);
-            limpiar_buffer_entrada(); // Limpiar el buffer de entrada
-            continue;
-        }
-
-        // Procesar y validar las coordenadas del barco.
-        if(procesar_coordenadas(ship_i, filaInicio, filaFin, columnaInicio, columnaFin, player_i)) {
-            // Asignar direccion del barco.
-            if (filaInicio == filaFin) {
-                ship_i->direction = (columnaInicio < columnaFin) ? 'E' : 'O';
-            } else if (columnaInicio == columnaFin) {
-                ship_i->direction = (filaInicio < filaFin) ? 'S' : 'N';
-            } else {
-                ship_i->direction = 'U'; // No debería ocurrir si las validaciones son correctas
-            }
-            // Si las coordenadas son validas, colocar el barco en el tablero.
-            colocar_barco_en_tablero(ship_i, filaInicio, filaFin, columnaInicio, columnaFin);
-        
-            // Incrementar el contador de barcos colocados.
-            player_i->placed_ships++;
-            coordenadas_validas = true; // Salir del bucle si todo es válido.
-        } else {
-            limpiar_buffer_entrada(); // Limpiar el buffer de entrada
-        }
-    if(coordenadas_validas) {
-        color_txt(SUCCESS_COLOR);
-        printf("Barco colocado exitosamente en");
-        color_txt(INFO_COLOR); 
-        printf(" (%d, %c)\n", filaInicio + 1, columnaInicio + 'A');
-        color_txt(DEFAULT_COLOR);
-        Sleep(1000); // Pausa para mostrar el mensaje de éxito.
-        limpiar_pantalla(); // Limpiar la pantalla después de colocar el barco.
-    }
-    
-    }
-}
-
-void colocar_barcos_jugador(struct player *player) {
-    printf("Colocando barcos para"); color_txt(INFO_COLOR); printf(" %s\n", player->name); color_txt(DEFAULT_COLOR);
-    for(int i = 0; i < NUM_SHIPS; i++) {
-        limpiar_pantalla();
-        printf("Colocando barcos de"); color_txt(INFO_COLOR); printf(" %s\n", player->name); color_txt(DEFAULT_COLOR);
-        imprimirTablero(player);
-        printf("Coloca tu barco de"); color_txt(INFO_COLOR); printf(" %d ",player->ships[i].size); color_txt(DEFAULT_COLOR);
-        printf("celdas.\nBarco"); color_txt(INFO_COLOR); printf(" %d ",i + 1); color_txt(DEFAULT_COLOR);
-        printf("de"); color_txt(INFO_COLOR); printf(" %d\n",NUM_SHIPS); color_txt(DEFAULT_COLOR);
-        ponerBarcos(&player->ships[i], player);
-    }
-    imprimirTablero(player);
-    printf("Barcos colocados correctamente. \n");
-    Sleep(1000);
-    limpiar_buffer_entrada();
-    enter_continuar();
-    limpiar_pantalla();
-}
-
-void solicitar_barco(struct player *player_i, struct player *enemy_i) {
-    int i, barco_seleccionado;
-    char opc;
-    do {
-        limpiar_pantalla();
-        printf("Turno de"); color_txt(INFO_COLOR); printf(" %s\n", player_i->name); color_txt(DEFAULT_COLOR);
-        imprimirTablero(player_i);    
-        printf("Seleccione el barco que desea mover:\n");
-        for (i = 0; i < NUM_SHIPS; i++) {
-            if (validar_movimiento(player_i, &player_i->ships[i])) {
-                // Mostrar solo barcos que se pueden mover
-                printf("Barco %d: %d celdas\n", i + 1, player_i->ships[i].size);
-            }
-        }
-        printf("[z]: No mover ningun barco.\n");
-        scanf(" %c", &opc);
-        opc = toupper(opc);
-        switch (opc) {
-            case 'Z':
-                printf("No se movera ningun barco. Recibes una carta de"); color_txt(INFO_COLOR); printf(" disparo.\n");
-                color_txt(DEFAULT_COLOR);
-                capturar_coordenada(player_i, enemy_i);
-                return;
-            case '1': case '2': case '3': case '4': case '5':
-                barco_seleccionado = opc - '1'; // Convertir a base 0
-                if (validar_movimiento(player_i, &player_i->ships[barco_seleccionado])) {       
-                    mover_barco_adelante(player_i, barco_seleccionado);
-                    return;
-                } else {
-                        color_txt(ERROR_COLOR);
-                    printf("No puedes mover ese barco.\n");
-                    color_txt(DEFAULT_COLOR);
-                    Sleep(2000); // Pausa para mostrar el mensaje de error.
-                    break; // Salir del bucle si el barco no se puede mover
-                }
-                break;
-            default:
-                color_txt(ERROR_COLOR);
-                printf("Opcion invalida. Intente de nuevo.\n");
-                color_txt(DEFAULT_COLOR);
-                Sleep(2000);
-            }
-        } while (1);
-}
-
-void reglas() {
-    char opc;
-    do {
-        limpiar_pantalla();
-        color_txt(INFO_COLOR);
-        printf("=== REGLAS DEL JUEGO \"BATALLA NAVAL\" ===\n\n");
-        color_txt(DEFAULT_COLOR);
-
-        color_txt(SUCCESS_COLOR);
-        printf("1. Cada jugador contara con una flota de barcos,\n");
-        color_txt(DEFAULT_COLOR);
-        printf("   la cual ordenara en una distribucion que considere conveniente para ocultarla de su rival.\n\n");
-
-        color_txt(SUCCESS_COLOR);
-        printf("2. El juego es por turnos.\n");
-        color_txt(DEFAULT_COLOR);
-        printf("   En cada turno se le proporcionara a cada jugador la posibilidad de usar una ");
-        color_txt(INFO_COLOR); printf("carta"); color_txt(DEFAULT_COLOR);
-        printf(" con diversos efectos sobre el tablero.\n\n");
-
-        color_txt(SUCCESS_COLOR);
-        printf("3. Las cartas disponibles son:\n");
-        color_txt(DEFAULT_COLOR);
-        printf("   ");
-        color_txt(INFO_COLOR); printf("- Disparo: "); color_txt(DEFAULT_COLOR);
-        printf("Dispara a una coordenada del tablero enemigo.\n   ");
-        color_txt(INFO_COLOR); printf("- Bombardeo de fila: "); color_txt(DEFAULT_COLOR);
-        printf("Bombardea una fila del tablero enemigo.\n   ");
-        color_txt(INFO_COLOR); printf("- Bombardeo de columna: "); color_txt(DEFAULT_COLOR);
-        printf("Bombardea una columna del tablero enemigo.\n   ");
-        color_txt(INFO_COLOR); printf("- Revelar: "); color_txt(DEFAULT_COLOR);
-        printf("Revela el estado de los barcos enemigos.\n   ");
-        color_txt(INFO_COLOR); printf("- Chequeo de fila: "); color_txt(DEFAULT_COLOR);
-        printf("Revela el estado de una fila del tablero enemigo.\n   ");
-        color_txt(INFO_COLOR); printf("- Chequeo de columna: "); color_txt(DEFAULT_COLOR);
-        printf("Revela el estado de una columna del tablero enemigo.\n   ");
-        color_txt(INFO_COLOR); printf("- Salvo: "); color_txt(DEFAULT_COLOR);
-        printf("Permite disparar a una coordenada del tablero enemigo sin que el enemigo pueda defenderse.\n   ");
-        color_txt(INFO_COLOR); printf("- Torre de ventaja: "); color_txt(DEFAULT_COLOR);
-        printf("Permite disparar a una coordenada y revela el estado de la fila y columna del barco.\n   ");
-        color_txt(INFO_COLOR); printf("- Revelar casilla aleatoria: "); color_txt(DEFAULT_COLOR);
-        printf("Permite revelar una casilla aleatoria en la que haya un barco enemigo.\n\n");
-
-        color_txt(SUCCESS_COLOR);
-        printf("4. El objetivo del juego es ");
-        color_txt(INFO_COLOR); printf("hundir todos los barcos del enemigo"); color_txt(DEFAULT_COLOR);
-        printf(" antes de que el enemigo hunda los tuyos.\n\n");
-
-        color_txt(SUCCESS_COLOR);
-        printf("5. Un barco se considera hundido cuando ");
-        color_txt(INFO_COLOR); printf("todas sus partes han sido alcanzadas."); color_txt(DEFAULT_COLOR);
-        printf("\n\n");
-
-        color_txt(ERROR_COLOR);
-        printf(" PROHIBIDO\n");
-        color_txt(DEFAULT_COLOR);
-        printf("   ");
-        color_txt(ERROR_COLOR); printf("- No puedes colocar barcos fuera del tablero.\n"); color_txt(DEFAULT_COLOR);
-        printf("   ");
-        color_txt(ERROR_COLOR); printf("- No puedes sobreponer barcos.\n"); color_txt(DEFAULT_COLOR);
-        printf("   ");
-        color_txt(ERROR_COLOR); printf("- No puedes disparar dos veces a la misma casilla.\n"); color_txt(DEFAULT_COLOR);
-        printf("   ");
-        color_txt(ERROR_COLOR); printf("- No puedes mover barcos una vez colocados.\n\n"); color_txt(DEFAULT_COLOR);
-
-        color_txt(INFO_COLOR);
-        printf("Consejos:\n");
-        color_txt(DEFAULT_COLOR);
-        printf("   - Piensa estrategicamente la ubicacion de tus barcos.\n");
-        printf("   - Aprovecha las cartas especiales para obtener ventaja.\n");
-        printf("   - Recuerda que la informacion revelada por cartas es temporal.\n\n");
-
-        color_txt(SUCCESS_COLOR);
-        printf("[Z]: Regresar al menu.\n");
-        color_txt(DEFAULT_COLOR);
-
-        scanf(" %c", &opc);
-        opc = toupper(opc);
-        limpiar_buffer_entrada();
-    } while (opc != 'Z');
-    limpiar_pantalla();
-    menu_principal();
-}
-
-void mostrar_turno_y_tablero(struct player *player_i, struct player *enemy_i) {
-    limpiar_pantalla(); // Limpiar la pantalla antes de mostrar el turno y tablero.
-    printf("Turno de"); color_txt(INFO_COLOR); printf(" %s\n", player_i->name); color_txt(DEFAULT_COLOR);
-    imprimirTableroGuerra(enemy_i, player_i); // Imprimir el tablero del enemigo.
-}
-
-void mostrar_info_carta(struct cartas *carta) {
-    printf("Te ha salido la carta:"); color_txt(INFO_COLOR); printf(" %s\n", carta->nombre); color_txt(DEFAULT_COLOR);
-    printf("Descripcion: %s\n", carta->descripcion);
-}
-
-void enter_continuar() {
-    printf("Presione enter para ");  color_txt(INFO_COLOR); printf("continuar.\n"); color_txt(DEFAULT_COLOR);
-    getchar(); // Pausa antes de continuar.
-}
diff --git a/codigo_fuente/bs_ui.h b/codigo_fuente/bs_ui.h
deleted file mode 100644
index bb6e6af..0000000
--- a/codigo_fuente/bs_ui.h
+++ /dev/null
@@ -1,43 +0,0 @@
-#ifndef BS_UI_H
-#define BS_UI_H
-
-#include "bs_common.h" // Incluye definiciones comunes
-
-
-// Function prototypes
-
-void pantalla_bienvenida();
-
-void menu_principal();
-
-void menu_por_turno(struct player *player_i, struct player *enemy_i);
-
-void solicitar_nombre(struct player *player);
-
-void partida();
-
-void capturar_coordenada(struct player *player_i, struct player *enemy_i);
-
-void capturar_fila_columna(int carta_id, struct player *player_i, struct player *enemy_i);
-
-void imprimirTablero(struct player *player_i);
-
-void imprimirTableroGuerra(struct player *enemy_i, struct player *player_i);
-
-void imprimirReporteBarcos(struct player *player_i, struct player *enemy_i);
-
-void ponerBarcos(struct ship *ship_i, struct player *player_i);
-
-void colocar_barcos_jugador(struct player *player_i);
-
-void solicitar_barco(struct player *player_i, struct player *enemy_i);
-
-void reglas();
-
-void mostrar_turno_y_tablero(struct player *player_i, struct player *enemy_i);
-
-void mostrar_info_carta(struct cartas *carta);
-
-void enter_continuar();
-
-#endif // BS_UI_H
\ No newline at end of file
diff --git a/codigo_fuente/codigo_fuente.code-workspace b/codigo_fuente/codigo_fuente.code-workspace
index dddfb90..519df57 100644
--- a/codigo_fuente/codigo_fuente.code-workspace
+++ b/codigo_fuente/codigo_fuente.code-workspace
@@ -10,7 +10,17 @@
 			"time.h": "c",
 			"bs_logic.h": "c",
 			"bs_console_utils.h": "c",
-			"bs_ui.h": "c"
+			"bs_ui.h": "c",
+			"stdlib.h": "c",
+			"string.h": "c",
+			"bs_ship.h": "c",
+			"windows.h": "c",
+			"bs_cards.h": "c",
+			"bs_board.h": "c",
+			"stdbool.h": "c",
+			"stdio.h": "c",
+			"bs_player.h": "c",
+			"bs_flow_card.h": "c"
 		}
 	}
 }
\ No newline at end of file
diff --git a/codigo_fuente/codigo_fuente.zip b/codigo_fuente/codigo_fuente.zip
deleted file mode 100644
index ad6c03e..0000000
Binary files a/codigo_fuente/codigo_fuente.zip and /dev/null differ
diff --git a/codigo_fuente/include/bs_board.h b/codigo_fuente/include/bs_board.h
new file mode 100644
index 0000000..8c328cc
--- /dev/null
+++ b/codigo_fuente/include/bs_board.h
@@ -0,0 +1,29 @@
+#ifndef BS_BOARD_H
+#define BS_BOARD_H
+
+#include "master.h"
+
+// administrar colocacion y movimiento de barcos
+
+bool validar_cc_rango(int cc_fila, int cc_columna);
+
+bool validar_orientacion(struct player *player, int index, int filaInicio, int filaFin, int columnaInicio, int columnaFin);
+
+bool validar_dimension(struct player *player, int index, int filaInicio, int filaFin, int columnaInicio, int columnaFin);
+
+bool validar_solapamiento(struct player *player, int index, int filaInicio, int filaFin, int columnaInicio, int columnaFin);
+
+// Administrar ataques a barcos
+
+bool validar_ataque_cc_rango(struct player *player);
+
+int barcos_en_fila(struct player *player, struct player *enemy);
+
+int barcos_en_columna(struct player *player, struct player *enemy);
+
+bool validar_estado_casilla(struct player *player, struct player *enemy);
+
+bool validar_entrada(char *input, int carta_id);
+
+
+#endif
\ No newline at end of file
diff --git a/codigo_fuente/include/bs_cards.h b/codigo_fuente/include/bs_cards.h
new file mode 100644
index 0000000..22ebc8d
--- /dev/null
+++ b/codigo_fuente/include/bs_cards.h
@@ -0,0 +1,26 @@
+#ifndef BS_CARDS_H
+#define BS_CARDS_H
+
+#include "master.h" // Libreria con todas las cabeceras del proyecto.
+
+void disparar(struct player *player, struct player *enemy);
+
+void bombardea_fila(struct player *player, struct player *enemy);
+
+void bombardea_columna(struct player *player, struct player *enemy);
+
+void revela(struct player *player, struct player *enemy);
+
+void chequeo_fila(struct player *player, struct player *enemy);
+
+void chequeo_columna(struct player *player, struct player *enemy);
+
+void activar_salvo(struct player *player);
+
+void desactivar_salvo(struct player *player);
+
+void torre_ventaja(struct player *player);
+
+void mover_barco_adelante(struct player *player, int id_barco);
+
+#endif // BS_EFECTOS_CARTAS_H
\ No newline at end of file
diff --git a/codigo_fuente/bs_common.h b/codigo_fuente/include/bs_common.h
similarity index 61%
rename from codigo_fuente/bs_common.h
rename to codigo_fuente/include/bs_common.h
index 312da1a..3923b4e 100644
--- a/codigo_fuente/bs_common.h
+++ b/codigo_fuente/include/bs_common.h
@@ -8,12 +8,12 @@
 #define MAX_NAME_LENGTH 21
 #define NUM_SHIPS 5
 #define VICTORYCONDITION 17 // Número de partes de barco que se deben hundir para ganar
-#define MAX_ID_10 4
+#define MAX_ID_9 4
 #define NUM_CARTAS 12
 #define CC_STATUS 2 // Columna de estado en la matriz de barcos
 #define CC_FILA 0 // Columna de fila en la matriz de barcos
 #define CC_COLUMNA 1 // Columna de columna en la matriz de barcos
-
+#define TOTAL_SHIP_PARTS VICTORYCONDITION // Número total de partes de barco
 // Valores numericos para interpretar el tablero
 #define WATER 0
 #define SHIP_STER 1
@@ -30,6 +30,8 @@
 // Common structure definitions
 struct ship
 {
+    int id; // ID del barco
+    char name[20]; // Nombre del barco
     int size; // alojar la dimension del barco
     char direction; // 'E' for east, 'W' for west, 'N' for north, 'S' for south, 'U' for undefined
     int **status; // status[size][3]: [fila][0]=x, [fila][1]=y, [fila][2]=estado (1=punta, 2=cuerpo, 3=punta dañada, 4=cuerpo dañado)
@@ -39,28 +41,44 @@ struct ship
 struct cartas
 {
     int id;
-    char nombre[20];
-    float probabilidad;
-    char descripcion[100];
+    char nombre[40];
+    char descripcion[150];
     int peso;
 };
 
 struct player
 {
+    // Variables de innicializacion
     char name[MAX_NAME_LENGTH];
+    int placed_ships;
     int turno; // Turno del jugador
+
+    // Variables para barcos
     struct ship ships[NUM_SHIPS]; // Array of ships for the player
-    int placed_ships; 
     int enemy_hit_parts; // Numero de partes de barco enemigo alcanzadas
     int sunked_ships; // Numero de barcos enemigos hundidos
+    
+    // Variables para cartas
     struct cartas cartas[NUM_CARTAS]; // Array de cartas
+    int peso_total; // Peso total de las cartas
     int torres_acumuladas; // Numero de torres acumuladas
     bool chequeo_fila[BOARD_SIZE]; // Variable para guardar la fila seleccionada por el jugador
+    int contador_fila[BOARD_SIZE]; // Contador para el chequeo de fila
+    int ultima_fila_chequeada; // Almacena la última fila chequeada
     bool chequeo_columna[BOARD_SIZE]; // Variable para guardar la columna seleccionada por el jugador
+    int contador_columna[BOARD_SIZE]; // Contador para el chequeo de columna
+    int ultima_columna_chequeada; // Almacena la última columna chequeada
     bool salvo;
     bool buff;
-};
 
+    // Variables de tipo buffer
+    int last_input_fila; // Almacena la última coordenada de disparo
+    int last_input_columna; // Almacena la última coordenada de disparo
+    int last_successful_shot_fila; // Almacena la última coordenada de disparo exitosa
+    char last_successful_shot_columna; // Almacena la última coordenada de disparo exitosa
+    int last_card_id; // Almacena el ID de la última carta utilizada
+    int aciertos_por_turno; // Almacena el número de aciertos por turno
+};
 
 
 #endif // BS_COMMON_H
\ No newline at end of file
diff --git a/codigo_fuente/include/bs_flow_card.h b/codigo_fuente/include/bs_flow_card.h
new file mode 100644
index 0000000..bde2aed
--- /dev/null
+++ b/codigo_fuente/include/bs_flow_card.h
@@ -0,0 +1,32 @@
+#ifndef BS_FLOW_CARD_H
+#define BS_FLOW_CARD_H
+
+#include "master.h"
+
+// Prototipos de funciones
+
+void funcion_carta_0(struct player *player, struct player *enemy);
+
+void funcion_carta_1(struct player *player, struct player *enemy);
+
+void funcion_carta_2(struct player *player, struct player *enemy);
+
+void funcion_carta_3(struct player *player, struct player *enemy);
+
+void funcion_carta_4(struct player *player, struct player *enemy);
+
+void funcion_carta_5(struct player *player, struct player *enemy);
+
+void funcion_carta_6(struct player *player, struct player *enemy);
+
+void funcion_carta_7(struct player *player, struct player *enemy);
+
+void funcion_carta_8(struct player *player);
+
+void funcion_carta_9(struct player *player_i, struct player *enemy_i);
+
+void funcion_carta_10(struct player *player_i, struct player *enemy_i);
+
+void funcion_carta_11(struct player *player_i, struct player *enemy_i);
+
+#endif // BS_FLOW_CARD_H
\ No newline at end of file
diff --git a/codigo_fuente/include/bs_game.h b/codigo_fuente/include/bs_game.h
new file mode 100644
index 0000000..5dd9695
--- /dev/null
+++ b/codigo_fuente/include/bs_game.h
@@ -0,0 +1,12 @@
+#ifndef BS_GAME_H
+#define BS_GAME_H
+
+#include "master.h" // Libreria con todas las cabeceras del proyecto.
+
+void partida();
+
+void menu_por_turno(struct player *player, struct player *enemy);
+
+void sacar_carta(struct player *player, struct player *enemy);
+
+#endif // BS_GAME_H
\ No newline at end of file
diff --git a/codigo_fuente/include/bs_logic.h b/codigo_fuente/include/bs_logic.h
new file mode 100644
index 0000000..adac3f3
--- /dev/null
+++ b/codigo_fuente/include/bs_logic.h
@@ -0,0 +1,22 @@
+#ifndef BS_LOGIC_H
+#define BS_LOGIC_H
+
+#include "master.h" // Libreria con todas las cabeceras del proyecto.
+
+// Prototipos de funciones
+
+bool procesar_coordenadas(struct player *player_i, int index, int filaInicio, int filaFin, int columnaInicio, int columnaFin);
+
+void colocar_barco_en_tablero(struct player *player, int index, int filaInicio, int filaFin, int columnaInicio, int columnaFin);
+
+void decidir_primer_turno(struct player *player1, struct player *player2);
+
+int obtener_id_aleatoria(struct player *player);
+
+int calcular_peso_total(struct player *player);
+
+bool validar_movimiento(struct player *player_i, struct ship *ship_i);
+
+
+
+#endif // BS_LOGIC_H
\ No newline at end of file
diff --git a/codigo_fuente/include/bs_player.h b/codigo_fuente/include/bs_player.h
new file mode 100644
index 0000000..9ebc69a
--- /dev/null
+++ b/codigo_fuente/include/bs_player.h
@@ -0,0 +1,16 @@
+#ifndef BS_PLAYER_H
+#define BS_PLAYER_H
+
+#include "master.h" // Incluye todas las cabeceras del proyecto
+
+void inicializar_jugador(struct player *player); // Inicializa un jugador
+
+void inicializar_cartas(struct player *player); // Inicializa las cartas del jugador
+
+void reset_input(struct player *player_i); // Reinicia las coordenadas de entrada del jugador
+
+void reset_sucessful_shot(struct player *player_i); // Reinicia el disparo exitoso del jugador
+
+void reset_card_id(struct player *player_i); // Reinicia el ID de la carta del jugador
+
+#endif
diff --git a/codigo_fuente/include/bs_ship.h b/codigo_fuente/include/bs_ship.h
new file mode 100644
index 0000000..1aca974
--- /dev/null
+++ b/codigo_fuente/include/bs_ship.h
@@ -0,0 +1,24 @@
+#ifndef BS_SHIP_H
+#define BS_SHIP_H
+
+#include "master.h" // Incluye todas las cabeceras del proyecto
+
+void inicializar_flota(struct player *player); // Inicializa la flota de barcos del jugador
+
+void inicializar_barco(struct ship *barco, int size); // Inicializa un barco con un tamaño específico
+
+bool posicion_barco(struct player *player, int index, int s_part, int fila, int columna); // Verifica si una parte del barco está en la posición (x, y)
+
+bool posicion_barco_enemy(struct player *player, int index, int s_part, struct player *enemy);
+
+bool casilla_saludable(struct player *enemy, int index, int s_part); // Verifica si una parte del barco está saludable
+
+void hundir_barco_buff(struct player *player, int index, struct player *enemy); // Hundir un barco enemigo con el buff activado
+
+void hundido(struct player *player, struct player *enemy); // Verifica si un barco enemigo ha sido hundido
+
+void liberar_status(struct ship *barco); // Libera la memoria del estado de un barco
+
+void liberar_flota(struct player *player); // Libera la memoria de la flota de barcos del jugador
+
+#endif
\ No newline at end of file
diff --git a/codigo_fuente/include/bs_ui.h b/codigo_fuente/include/bs_ui.h
new file mode 100644
index 0000000..093f3ef
--- /dev/null
+++ b/codigo_fuente/include/bs_ui.h
@@ -0,0 +1,46 @@
+#ifndef BS_UI_H
+#define BS_UI_H
+
+#include "master.h" // Libreria con todas las cabeceras del proyecto.
+
+// Function prototypes
+
+void pantalla_bienvenida();
+
+void menu_principal();
+
+void reglas();
+
+void solicitar_nombre(struct player *player);
+
+void colocar_barcos_jugador(struct player *player);
+
+void imprimirTablero(struct player *player);
+
+void ponerBarcos(struct player *player, int index);
+
+void mostrar_turno_y_tablero_G(struct player *player, struct player *enemy);
+
+void imprimirTableroGuerra(struct player *enemy, struct player *player);
+
+void imprimirReporteBarcosEnemigos(struct player *player, struct player *enemy);
+
+void imprimirReporteBarcos(struct player *player, struct player *enemy);
+
+void mostrar_turno_y_tablero(struct player *player);
+
+void mostrar_info_carta(struct cartas *carta);
+
+void capturar_coordenada(struct player *player, struct player *enemy);
+
+void mostrar_ultimo_disparo_exitoso(struct player *player_i);
+
+void mostrar_bomb_cheq_exitoso(struct player *player_i);
+
+
+
+void capturar_fila_columna(struct player *player_i, struct player *enemy_i);
+
+void solicitar_barco(struct player *player_i, struct player *enemy_i);
+
+#endif // BS_UI_H
\ No newline at end of file
diff --git a/codigo_fuente/bs_console_utils.h b/codigo_fuente/include/bs_utils.h
similarity index 55%
rename from codigo_fuente/bs_console_utils.h
rename to codigo_fuente/include/bs_utils.h
index 8895cc2..3e848cb 100644
--- a/codigo_fuente/bs_console_utils.h
+++ b/codigo_fuente/include/bs_utils.h
@@ -1,11 +1,9 @@
 #ifndef BS_CONSOLE_UTILS_H
 #define BS_CONSOLE_UTILS_H
 
-#include <windows.h> // libreria para poder usar la funcion Sleep.
-
-static inline void limpiar_pantalla(){
-	system("cls");
-}
+#include "master.h" // Incluye todas las cabeceras del proyecto
+#include <windows.h> // Libreria para usar funciones de consola en Windows
+#include <stdio.h>    // Para usar getchar() y EOF
 
 /* Códigos ANSI básicos */
 #define NEGRO           0
@@ -34,9 +32,27 @@ static inline void limpiar_pantalla(){
 #define SUCCESS_COLOR    VERDE
 #define INV_COLOR        NEGRO
 
-static inline void color_txt(int color)
-{
+static inline void limpiar_pantalla(){
+	system("cls");
+}
+
+static inline void color_txt(int color) {
     SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), color);
 }
 
+static inline void limpiar_buffer_entrada() {
+    int c;
+    while ((c = getchar()) != '\n' && c != EOF);
+}
+
+static inline void pausa_consola(float segundos) {
+    Sleep(segundos * 1000);
+}
+
+static inline void enter_continuar() {
+    printf("Presione enter para ");  color_txt(INFO_COLOR); printf("continuar.\n"); color_txt(DEFAULT_COLOR);
+    while (getchar() != '\n'); // Esperar a que el usuario presione enter.
+    limpiar_pantalla(); // Limpiar la pantalla después de mostrar el mensaje.
+}
+
 #endif
\ No newline at end of file
diff --git a/codigo_fuente/include/master.h b/codigo_fuente/include/master.h
new file mode 100644
index 0000000..29e5977
--- /dev/null
+++ b/codigo_fuente/include/master.h
@@ -0,0 +1,23 @@
+#ifndef MASTER_H
+#define MASTER_H
+
+// Todas las librerias del proyecto
+#include "bs_common.h"
+#include "bs_utils.h"
+#include "bs_board.h"
+#include "bs_ship.h"
+#include "bs_player.h"
+#include "bs_cards.h"
+#include "bs_logic.h"
+#include "bs_ui.h"
+#include "bs_game.h"
+#include "bs_flow_card.h"
+#include <stdbool.h> // incluye definiciones de tipo booleano estándar
+#include <time.h> // libreria para poder usar la funcion time.
+#include <stdio.h> // libreria para poder usar la funcion printf.
+#include <stdlib.h> // libreria para poder usar la funcion system.
+#include <string.h> // libreria para poder usar la funcion strcspn.
+#include <windows.h> // libreria para poder usar la funcion Sleep.
+#include <ctype.h> // libreria para poder usar la funcion toupper.
+#include <errno.h> // libreria para poder usar la funcion errno.
+#endif // MASTER_H
\ No newline at end of file
diff --git a/codigo_fuente/main.c b/codigo_fuente/main.c
deleted file mode 100644
index e8ec65f..0000000
--- a/codigo_fuente/main.c
+++ /dev/null
@@ -1,15 +0,0 @@
-#include <stdio.h> // libreria para poder usar la funcion printf.
-#include <stdlib.h> // libreria para poder usar la funcion system.
-#include "bs_common.h" // Incluye definiciones comunes
-#include "bs_console_utils.h" // libreria para poder usar la funcion limpiar y cambio de color.
-#include "bs_logic.h" // libreria para poder usar funciones de logica.
-#include "bs_ui.h" // libreria para poder usar funciones de UI.
-#include <string.h> // libreria para poder usar la funcion strcspn.
-
-int main() {
-	pantalla_bienvenida(); // Pantalla de bienvenida.
-	limpiar_pantalla(); // Limpiar la pantalla después de la bienvenida.
-	menu_principal(); // Menu principal.
-	
-	return 0; // Fin del programa.
-}
\ No newline at end of file
diff --git a/codigo_fuente/src/bs_board.c b/codigo_fuente/src/bs_board.c
new file mode 100644
index 0000000..6f1452f
--- /dev/null
+++ b/codigo_fuente/src/bs_board.c
@@ -0,0 +1,243 @@
+#include "bs_board.h"
+
+// Administrar colocacion y movimiento de barcos
+
+bool validar_cc_rango(int cc_fila, int cc_columna) {
+    if (cc_fila >= 0 && cc_fila < BOARD_SIZE && 
+        cc_columna >= 0 && cc_columna < BOARD_SIZE) {
+        return true; // Coordenadas válidas
+    }
+    if (cc_fila < 0 || cc_fila >= BOARD_SIZE) {
+        color_txt(ERROR_COLOR);
+        printf("Coordenada fuera de rango(Fila).");
+
+    } else if (cc_columna < 0 || cc_columna >= BOARD_SIZE) {
+        color_txt(ERROR_COLOR);
+        printf("Coordenada fuera de rango(Columna).");
+    }
+    color_txt(INFO_COLOR); printf(" CodeError: 1\n");
+    color_txt(DEFAULT_COLOR);
+    return false;
+}
+
+bool validar_orientacion(struct player *player, int index, int filaInicio, int filaFin, int columnaInicio, int columnaFin) {
+    if (!(filaInicio == filaFin || columnaInicio == columnaFin)) {
+        color_txt(ERROR_COLOR);
+        printf("Orientacion no permitida, el barco debe ser horizontal o vertical."); color_txt(INFO_COLOR); printf(" CodeError: 2\n");
+        color_txt(DEFAULT_COLOR);
+        return false;
+    } else { // Si la orientación es válida, asignar la dirección.
+        if (filaInicio == filaFin) {
+            player->ships[index].direction = (columnaInicio < columnaFin) ? 'E' : 'O';
+        } else if (columnaInicio == columnaFin) {
+            player->ships[index].direction = (filaInicio < filaFin) ? 'S' : 'N';
+        } else {
+            player->ships[index].direction = 'U'; // No debería ocurrir si las validaciones son correctas
+        }
+        return true; // Orientación válida
+    }
+}
+
+bool validar_dimension( struct player *player, int index, int filaInicio, int filaFin, int columnaInicio, int columnaFin) {
+    int dimension_actual;
+
+    if (player->ships[index].direction == 'E' || player->ships[index].direction == 'O') {
+        dimension_actual = abs(columnaFin - columnaInicio) + 1;
+    } else {
+        dimension_actual = abs(filaFin - filaInicio) + 1;
+    }
+    if (dimension_actual != player->ships[index].size) {
+        color_txt(ERROR_COLOR);
+        printf("Las coordenadas no son validas. El barco debe tener"); color_txt(INFO_COLOR); printf(" %d", player->ships[index].size);
+        color_txt(ERROR_COLOR); printf(" celdas de longitud.", player->ships[index].size); color_txt(INFO_COLOR); printf(" CodeError: 3\n");
+        color_txt(DEFAULT_COLOR);
+        return false;
+    }
+    return true; // Dimensión válida
+}
+
+bool validar_solapamiento(struct player *player, int index, int filaInicio, int filaFin, int columnaInicio, int columnaFin) {
+    int i, x, y, idx_ship, s_part;
+
+    // Recorre todas las posiciones que ocuparía el nuevo barco
+    if (player->ships[index].direction == 'E' || player->ships[index].direction == 'O') {
+        // Horizontal
+        for (i = columnaInicio; (player->ships[index].direction == 'E') ? (i <= columnaFin) : (i >= columnaFin); (player->ships[index].direction == 'E') ? i++ : i--) {
+            x = filaInicio;
+            y = i;
+            // Compara contra todos los barcos ya colocados
+            for (idx_ship = 0; idx_ship < player->placed_ships; idx_ship++) {
+                for (s_part = 0; s_part < player->ships[idx_ship].size; s_part++) {
+                    // Solo compara si la casilla ya fue asignada (no -1)
+                    if ((posicion_barco(player, idx_ship, s_part, x, y)) && x != -1 && y != -1) {
+                        color_txt(ERROR_COLOR);
+                        printf("Solapamiento detectado en"); color_txt(INFO_COLOR); printf(" %d,%d", x, y); 
+                        color_txt(DEFAULT_COLOR); printf(" con el barco %d", idx_ship + 1);
+                        color_txt(INFO_COLOR); printf(" CodeError: 4\n"); color_txt(DEFAULT_COLOR);
+                        return false; // Hay solapamiento
+                    }
+                }
+            }
+        }
+    } 
+    // Vertical
+    else {    
+        for (i = filaInicio; (player->ships[index].direction == 'S') ? (i <= filaFin) : (i >= filaFin); (player->ships[index].direction == 'S') ? i++ : i--) {
+            x = i;
+            y = columnaInicio;
+            for (s_part = 0; s_part < player->ships[idx_ship].size; s_part++) {
+                // Solo compara si la casilla ya fue asignada (no -1)
+                if ((posicion_barco(player, idx_ship, s_part, x, y)) && x != -1 && y != -1) {
+                    color_txt(ERROR_COLOR);
+                    printf("Solapamiento detectado en"); color_txt(INFO_COLOR); printf(" %d,%d", x, y);
+                    color_txt(DEFAULT_COLOR); printf(" con el barco %d", idx_ship + 1);
+                    color_txt(INFO_COLOR); printf(" CodeError: 4\n"); color_txt(DEFAULT_COLOR);
+                    return false; // Hay solapamiento
+                }
+            }
+        }
+    }
+    return true; // No hay solapamiento
+}
+
+// Administrar ataques a barcos
+
+bool validar_ataque_cc_rango(struct player *player) {
+    int f = player->last_input_fila;
+    int c = player->last_input_columna;
+
+    // Cartas que solo requieren validar fila
+    if (player->last_card_id == 3 || player->last_card_id == 6) {
+        if (f < 0 || f >= BOARD_SIZE) {
+            color_txt(ERROR_COLOR);
+            printf("Fila fuera del tablero de juego.");
+            color_txt(INFO_COLOR); printf(" CodeError: 1\n");
+            color_txt(DEFAULT_COLOR);
+        }
+        return (f >= 0 && f < BOARD_SIZE); // Solo fila es válida
+    }
+    if (player->last_card_id == 4 || player->last_card_id == 7) {
+        if (c < 0 || c >= BOARD_SIZE) {
+            color_txt(ERROR_COLOR);
+            printf("Columna fuera del tablero de juego.");
+            color_txt(INFO_COLOR); printf(" CodeError: 1\n");
+            color_txt(DEFAULT_COLOR);
+        }
+        return (c >= 0 && c < BOARD_SIZE); // Solo columna es válida
+    }
+    // Cartas que requieren validar fila y columna
+    return validar_cc_rango(f, c);
+}
+
+int barcos_en_fila(struct player *player, struct player *enemy) {
+    int contador = 0;
+    
+    // bf = barrido de fila
+    for (int bf = 0; bf < BOARD_SIZE; bf++) {
+        for (int idx_ship = 0; idx_ship < NUM_SHIPS; idx_ship++) {
+            for (int s_part = 0; s_part < enemy->ships[idx_ship].size; s_part++) {
+                // Comprobar si la parte del barco coincide con la fila y no está dañado
+                if (enemy->ships[idx_ship].status[s_part][CC_FILA] == player->last_input_fila && casilla_saludable(enemy, idx_ship, s_part)) {
+                    contador++;
+                }
+            }
+        }
+    }
+    return contador;
+}
+
+int barcos_en_columna(struct player *player, struct player *enemy) {
+    int contador = 0;
+
+    // bc = barrido de columna
+    for (int bc = 0; bc < BOARD_SIZE; bc++) {
+        for (int idx_ship = 0; idx_ship < NUM_SHIPS; idx_ship++) {
+            for (int s_part = 0; s_part < enemy->ships[idx_ship].size; s_part++) {
+                // Comprobar si la parte del barco coincide con la columna y no está dañado
+                if (enemy->ships[idx_ship].status[s_part][CC_COLUMNA] == player->last_input_columna && (casilla_saludable(enemy, idx_ship, s_part))) {
+                    contador++;
+                }
+            }
+        }
+    }
+    return contador;
+}
+
+bool validar_estado_casilla(struct player *player, struct player *enemy) {
+    // ¿Hay barco en la coordenada?
+    for (int idx_ship = 0; idx_ship < NUM_SHIPS; idx_ship++) {
+        for (int s_part = 0; s_part < enemy->ships[idx_ship].size; s_part++) {
+            if (posicion_barco_enemy(player, idx_ship, s_part, enemy)) {
+                if (!casilla_saludable(enemy, idx_ship, s_part)) { // Si la casilla esta dañada
+                    color_txt(ERROR_COLOR);
+                        printf("Casilla ya disparada previamente");
+                    color_txt(INFO_COLOR);
+                        printf(" CodeError: 5\n");
+                    color_txt(DEFAULT_COLOR);
+                    return false; // Ya disparado
+                }
+                return true; // Casilla válida para disparar
+            }
+        }
+    }
+    return true; // No habia barco → puede disparar (agua)
+}
+
+bool validar_entrada(char *input, int carta_id) {
+    char *endptr;
+    long num;
+    char *salto_linea;
+    char c;
+
+    // SOLO fila (letra)
+    if (carta_id == 3 || carta_id == 6) {
+        salto_linea = strchr(input, '\n');
+        if (!salto_linea) {
+            color_txt(ERROR_COLOR); printf("Debe ingresar una letra.");
+            color_txt(INFO_COLOR); printf(" CodeError: 0\n");
+            color_txt(DEFAULT_COLOR);
+            return false;
+        }
+        *salto_linea = '\0';
+        if (strlen(input) != 1 || !isalpha((unsigned char)input[0])) {
+            color_txt(ERROR_COLOR); printf("Formato de entrada invalido.");
+            color_txt(INFO_COLOR); printf(" CodeError: 1\n");
+            color_txt(DEFAULT_COLOR);
+            return false;
+        }
+        c = toupper((unsigned char)input[0]);
+        if (c < 'A' || c > 'A' + BOARD_SIZE - 1) {
+            color_txt(ERROR_COLOR); printf("Fila fuera del tablero de juego.");
+            color_txt(INFO_COLOR); printf(" CodeError: 2\n");
+            color_txt(DEFAULT_COLOR);
+            return false;
+        }
+        return true;
+    }
+    // SOLO columna (número)
+    else if (carta_id == 4 || carta_id == 7) {
+        if (strchr(input, '\n') == NULL) {
+            color_txt(ERROR_COLOR); printf("Debe ingresar un numero.");
+            color_txt(INFO_COLOR); printf(" CodeError: 0\n");
+            color_txt(DEFAULT_COLOR);
+            return false;
+        }
+        input[strcspn(input, "\n")] = '\0';
+        errno = 0;
+        num = strtol(input, &endptr, 10);
+        if (errno == ERANGE || *endptr != '\0') {
+            color_txt(ERROR_COLOR); printf("Formato de entrada invalido.");
+            color_txt(INFO_COLOR); printf(" CodeError: 1\n");
+            color_txt(DEFAULT_COLOR);
+            return false;
+        }
+        if (num < 1 || num > BOARD_SIZE) {
+            color_txt(ERROR_COLOR); printf("Columna fuera del tablero de juego.");
+            color_txt(INFO_COLOR); printf(" CodeError: 3\n");
+            color_txt(DEFAULT_COLOR);
+            return false;
+        }
+        return true;
+    }
+    return false;
+}
diff --git a/codigo_fuente/src/bs_cards.c b/codigo_fuente/src/bs_cards.c
new file mode 100644
index 0000000..032591c
--- /dev/null
+++ b/codigo_fuente/src/bs_cards.c
@@ -0,0 +1,203 @@
+#include "bs_cards.h" // libreria para poder usar funciones de efectos de cartas.
+
+void disparar(struct player *player, struct player *enemy) {
+    bool disparo_exitoso = false; // Variable para verificar si el disparo fue exitoso
+
+    for (int idx_ship = 0; idx_ship < NUM_SHIPS; idx_ship++) { // Recorre todos los barcos enemigos
+        for (int s_part = 0; s_part < enemy->ships[idx_ship].size; s_part++) { // Recorre todas las partes del barco
+            if (posicion_barco(enemy, idx_ship, s_part, 
+                                player->last_input_fila, 
+                                player->last_input_columna)) {
+                disparo_exitoso = true;
+                
+                // Guarda la última coordenada de disparo exitosa
+                player->last_successful_shot_fila = player->last_input_fila; 
+                player->last_successful_shot_columna = player->last_input_columna;
+
+                if (player->buff) {
+                    // Modifica todo el barco a dañado(hundido)
+                    mostrar_ultimo_disparo_exitoso(player);
+                    hundir_barco_buff(player, idx_ship, enemy);
+
+                } else {
+                    // Modifica el estado de la parte del barco a dañada
+                    enemy->ships[idx_ship].status[s_part][CC_STATUS] += 2;
+                    mostrar_ultimo_disparo_exitoso(player);
+                    pausa_consola(1.3);
+                    player->enemy_hit_parts++;
+                    player->aciertos_por_turno++;
+                    hundido(player, enemy); // Verifica si el barco está hundido
+                }
+                break; // Salir del bucle si se encuentra una parte del barco
+            }
+        }
+        
+    }
+    if (!disparo_exitoso) {
+            color_txt(ERROR_COLOR);
+            printf("Disparo fallido"); color_txt(DEFAULT_COLOR);
+            printf(" en %c,%d! Disparaste al", 
+                    player->last_input_fila + 'A',
+                    player->last_input_columna + 1);
+            color_txt(WATER_COLOR); printf(" agua.\n"); color_txt(DEFAULT_COLOR);
+    }
+}
+
+void bombardea_fila(struct player *player, struct player *enemy) {
+    // Recorre todos los barcos enemigos y daña las partes en la fila dada
+    for (int idx_ship = 0; idx_ship < NUM_SHIPS; idx_ship++) {
+        for (int s_part = 0; s_part < enemy->ships[idx_ship].size; s_part++) {
+            if (enemy->ships[idx_ship].status[s_part][CC_FILA] == player->last_input_fila) {
+                if (casilla_saludable(enemy, idx_ship, s_part)) {
+                    if (player->buff) {
+                        printf("Disparo exitoso en %c,%d!\n", player->last_input_fila + 'A', enemy->ships[idx_ship].status[s_part][CC_COLUMNA] + 1);
+                        hundir_barco_buff(player, idx_ship, enemy);
+                        //printf("Haz hundido el barco!\n");
+                        hundido(enemy, player); // Verifica si el barco está hundido
+                        pausa_consola(1.3);
+                        break; // Salir del bucle si se hunde el barco
+                    } else {
+                    enemy->ships[idx_ship].status[s_part][CC_STATUS] += 2; // Modifica el estado de la parte del barco a dañada
+                    player->enemy_hit_parts++; // Incrementa el contador de partes dañadas del enemigo
+                    player->aciertos_por_turno++; // Incrementa el contador de aciertos por turno
+                    printf("Disparo exitoso en %c,%d\n", player->last_input_fila + 'A', enemy->ships[idx_ship].status[s_part][CC_COLUMNA] + 1);
+                    hundido(enemy, player); // Verifica si el barco está hundido
+                    pausa_consola(1.3);
+                    }
+                    player->last_successful_shot_fila = player->last_input_fila; // Guarda la última fila disparada
+                }
+            }
+        }
+    }
+}
+
+void bombardea_columna(struct player *player, struct player *enemy) {
+    // Recorre todos los barcos enemigos y daña las partes en la columna dada
+    for (int idx_ship = 0; idx_ship < NUM_SHIPS; idx_ship++) {
+        for (int s_part = 0; s_part < enemy->ships[idx_ship].size; s_part++) {
+            if (enemy->ships[idx_ship].status[s_part][CC_COLUMNA] == player->last_input_columna) {
+                if (casilla_saludable(enemy, idx_ship, s_part)) {
+                    if (player->buff) {
+                        printf("Disparo exitoso en %c,%d!\n", enemy->ships[idx_ship].status[s_part][CC_FILA] + 'A', player->last_input_columna + 1);
+                        hundir_barco_buff(player, idx_ship, enemy);
+                        hundido(enemy, player); // Verifica si el barco está hundido
+                        break; // Salir del bucle si se hunde el barco
+                    } else {
+                        enemy->ships[idx_ship].status[s_part][CC_STATUS] += 2; // Modifica el estado de la parte del barco a dañada
+                        player->enemy_hit_parts++; // Incrementa el contador de partes dañadas del enemigo
+                        player->aciertos_por_turno++; // Incrementa el contador de aciertos por turno
+                        printf("Disparo exitoso en %c,%d\n", enemy->ships[idx_ship].status[s_part][CC_FILA] + 'A', player->last_input_columna + 1);
+                        hundido(enemy, player); // Verifica si el barco está hundido
+                    }
+                    player->last_successful_shot_columna = player->last_input_columna; // Guarda la última columna disparada
+                }
+            }
+        }
+    }
+}
+
+void revela(struct player *player, struct player *enemy) {
+    // 1. Guardar todas las partes de barco no dañadas
+    int posibles[TOTAL_SHIP_PARTS - player->enemy_hit_parts][CC_STATUS]; // Máximo 5 partes por barco
+    int total = 0;
+    int s, p;
+
+    for (s = 0; s < NUM_SHIPS; s++) {
+        struct ship *barco = &enemy->ships[s];
+        for (p = 0; p < barco->size; p++) {
+            // Si la parte no está dañada (1 = punta, 2 = cuerpo)
+            if (barco->status[p][CC_STATUS] == SHIP_STER || barco->status[p][CC_STATUS] == SHIP_BODY) {
+                posibles[total][0] = barco->status[p][CC_FILA]; // fila
+                posibles[total][1] = barco->status[p][CC_COLUMNA]; // columna
+                total++;
+            }
+        }
+    }
+    // 2. Elegir una coordenada aleatoria
+    int idx = rand() % total;
+    int fila = posibles[idx][0];
+    int columna = posibles[idx][1];
+
+
+    printf("Presione enter para revelar...\n");
+    color_txt(INFO_COLOR);
+    printf("---> ");
+    color_txt(ERROR_COLOR);
+    printf("(%c,%d)", fila + 'A', columna + 1);
+    color_txt(INFO_COLOR);
+    printf(" <---\n");
+    color_txt(DEFAULT_COLOR);
+    pausa_consola(1);
+    
+    printf("Presione enter para disparar...\n");
+    getchar();
+    for (s = 0; s < NUM_SHIPS; s++) {
+        for (p = 0; p < enemy->ships[s].size; p++) {
+            if (posicion_barco(enemy, s, p, fila, columna)) {
+                // Modifica el estado de la parte del barco a dañada (sin validaciones)
+                enemy->ships[s].status[p][CC_STATUS] += 2;
+                break;
+            }
+        }
+    }
+    limpiar_pantalla();
+    mostrar_turno_y_tablero_G(player, enemy);
+    printf("Disparo exitoso en %c,%d!\n", fila + 'A', columna + 1);
+    player->enemy_hit_parts++;
+    hundido(enemy, player); // Verifica si el barco está hundido
+}
+
+void chequeo_fila(struct player *player, struct player *enemy) {
+    player->chequeo_fila[player->last_input_fila] = true;
+    player->contador_fila[player->last_input_fila] = barcos_en_fila(player, enemy);
+}
+
+void chequeo_columna(struct player *player, struct player *enemy) {
+    player->chequeo_columna[player->last_input_columna] = true;
+    player->contador_columna[player->last_input_columna] = barcos_en_columna(player, enemy);
+}
+
+void activar_salvo(struct player *player) {
+    player->salvo = true;
+}
+
+void desactivar_salvo(struct player *player) {
+    player->salvo = false;
+}
+
+void torre_ventaja(struct player *player) {
+    player->buff = true;
+}
+
+void mover_barco_adelante(struct player *player, int id_barco) {
+    struct ship *ship_i = &player->ships[id_barco];
+    int prev_pos[ship_i->size][2];
+    int i;
+
+    // Guardar la posición anterior del barco
+    for (i = 0; i < ship_i->size; i++) {
+        prev_pos[i][0] = ship_i->status[i][0];
+        prev_pos[i][1] = ship_i->status[i][1];
+    }
+
+    if (ship_i->direction == 'E') {
+        ship_i->status[0][1] ++;
+    // Mover barco hacia el oeste
+    } else if (ship_i->direction == 'O') {
+        ship_i->status[0][1] --;
+    // Mover barco hacia el sur
+    } else if (ship_i->direction == 'S') {
+        ship_i->status[0][0] ++;
+    // Mover barco hacia el norte
+    } else if (ship_i->direction == 'N') {
+        ship_i->status[0][0] --;
+    } else {
+        return; // No se puede mover el barco
+    }
+
+    // Mover el resto del barco
+    for (i = 1; i < ship_i->size; i++) {
+        ship_i->status[i][0] = prev_pos[i - 1][0];
+        ship_i->status[i][1] = prev_pos[i - 1][1];
+    }
+}
\ No newline at end of file
diff --git a/codigo_fuente/src/bs_flow_card.c b/codigo_fuente/src/bs_flow_card.c
new file mode 100644
index 0000000..5b611e7
--- /dev/null
+++ b/codigo_fuente/src/bs_flow_card.c
@@ -0,0 +1,181 @@
+#include "bs_flow_card.h"
+
+void funcion_carta_0(struct player *player, struct player *enemy) {
+    int disparos = player->salvo ? (NUM_SHIPS - enemy->sunked_ships) : 1;
+    for (int i = 0; i < disparos; i++) {
+        if (i == 0) {
+            printf("Dispara una vez.\n");
+        } else if (i < disparos - 1) {
+            mostrar_turno_y_tablero_G(player, enemy);
+            printf("Dispara de nuevo.\n");
+        } else {
+            mostrar_turno_y_tablero_G(player, enemy);
+            printf("Dispara una vez mas.\n");
+        }
+        pausa_consola(1.3);
+        capturar_coordenada(player, enemy);
+        limpiar_buffer_entrada(); // Limpiar el buffer de entrada para evitar problemas con la entrada del usuario.
+        enter_continuar();
+        mostrar_turno_y_tablero_G(player, enemy); // Mostrar el tablero después de disparar.
+        printf("Tablero de guerra actualizado:\n");
+        mostrar_ultimo_disparo_exitoso(player); // Mostrar el último disparo exitoso.
+        pausa_consola(1);
+        if(player->salvo) {
+            enter_continuar();
+        } else break; // Si no es modo Salvo, salir del bucle después de un disparo.
+    }
+    enter_continuar();
+}
+
+void funcion_carta_1(struct player *player, struct player *enemy) {
+    // Primer disparo
+    for(int i = 1; i <= 2; i++) {
+        if (i == 1) {
+            printf("Dispara una vez.\n");
+        } else {
+            mostrar_turno_y_tablero_G(player, enemy);
+            printf("Dispara de nuevo.\n");
+        }
+        pausa_consola(1.3);
+        capturar_coordenada(player, enemy);
+        enter_continuar();
+        mostrar_turno_y_tablero_G(player, enemy);
+        printf("Tablero de guerra actualizado:\n");
+        mostrar_ultimo_disparo_exitoso(player);
+        pausa_consola(1);
+        enter_continuar();
+    }
+}
+
+void funcion_carta_2(struct player *player, struct player *enemy) {
+    for(int i = 1; i <= 3; i++) {
+        if (i == 1) {
+            printf("Dispara una vez.\n");
+        } else if (i == 2) {
+            mostrar_turno_y_tablero_G(player, enemy);
+            printf("Dispara de nuevo.\n");
+        } else {
+            mostrar_turno_y_tablero_G(player, enemy);
+            printf("Dispara una vez mas.\n");
+        }
+        pausa_consola(1.3);
+        capturar_coordenada(player, enemy);
+        enter_continuar();
+        mostrar_turno_y_tablero_G(player, enemy);
+        printf("Tablero de guerra actualizado:\n");
+        mostrar_ultimo_disparo_exitoso(player);
+        pausa_consola(1);
+        enter_continuar();
+    }
+}
+
+void funcion_carta_3(struct player *player, struct player *enemy) {
+    if (player->ships[1].vivo) {
+        printf("Su barco de %d casillas logro activar su habilidad especial.\n", player->ships[1].size);
+        capturar_fila_columna(player, enemy);
+    } else {
+        printf("No hemos podido activar la carta. El barco de %d casillas no esta a flote.\n", player->ships[1].size);
+        printf("Solo pudimos activar la carta de 1 disparo.\n");
+        capturar_coordenada(player, enemy);
+
+    }
+    enter_continuar();
+    mostrar_turno_y_tablero_G(player, enemy);
+    printf("Tablero de guerra actualizado:\n");
+    mostrar_bomb_cheq_exitoso(player);
+    pausa_consola(1);
+    enter_continuar();
+}
+
+void funcion_carta_4(struct player *player, struct player *enemy) {
+    if (player->ships[0].vivo) {
+        printf("Su barco de %d casillas logro activar su habilidad especial.\n", player->ships[0].size);
+        capturar_fila_columna(player, enemy);
+    } else {
+        printf("No hemos podido activar la carta. El barco de %d casillas no esta a flote.\n", player->ships[0].size);
+        printf("Solo pudimos activar la carta de 1 disparo.\n");
+        capturar_coordenada(player, enemy);
+    }
+
+    limpiar_buffer_entrada(); // Limpiar el buffer de entrada para evitar problemas con la entrada del usuario.
+    enter_continuar();
+    mostrar_turno_y_tablero_G(player, enemy);
+    printf("Tablero de guerra actualizado:\n");
+    mostrar_bomb_cheq_exitoso(player);
+    pausa_consola(1);
+    enter_continuar();
+}
+
+void funcion_carta_5(struct player *player, struct player *enemy) {
+    printf("Inteligencia a decifrado con exito la ubicacion de una casilla enemiga.\n");
+    revela(enemy, player);
+    enter_continuar();
+}
+
+void funcion_carta_6(struct player *player, struct player *enemy) {
+    printf("Hemos logrado activar el radar de filas.\n");
+    capturar_fila_columna(player, enemy);
+    limpiar_buffer_entrada(); // Limpiar el buffer de entrada para evitar problemas con la entrada del usuario.
+    enter_continuar();
+    mostrar_turno_y_tablero_G(player, enemy);
+    printf("Tablero de guerra actualizado:\n");
+    mostrar_bomb_cheq_exitoso(player);
+    pausa_consola(1);
+    enter_continuar();
+}
+
+void funcion_carta_7(struct player *player, struct player *enemy) {
+    printf("Hemos logrado activar el radar de columnas.\n");
+    capturar_fila_columna(player, enemy);
+    limpiar_buffer_entrada(); // Limpiar el buffer de entrada para evitar problemas con la entrada del usuario.
+    enter_continuar();
+    mostrar_turno_y_tablero_G(player, enemy);
+    printf("Tablero de guerra actualizado:\n");
+    mostrar_bomb_cheq_exitoso(player);
+    pausa_consola(1);
+    enter_continuar();
+}
+
+void funcion_carta_8(struct player *player) {
+    activar_salvo(player);
+    printf("\nModo Salvo activado\n");
+    printf("Durante este turno NO disparas. En tu proximo turno, podras disparar multiples veces.\n");
+    pausa_consola(1.3);
+    enter_continuar();
+}
+
+void funcion_carta_9(struct player *player, struct player *enemy) {
+    if(player->torres_acumuladas < MAX_ID_9) {
+            player->torres_acumuladas++;
+            printf("Has acumulado una torre de ventaja. Acumula 4 para hundir instantaneamente los barcos enemigos.\n");
+            // Reducir el peso de la carta Torre de ventaja
+            if (player->cartas[9].peso > 0) player->cartas[9].peso--;
+    } else torre_ventaja(player);
+    printf("En este turno no disparas.\n");
+    enter_continuar();
+}
+
+void funcion_carta_10(struct player *player, struct player *enemy) {
+    printf("Puedes disparar una vez, luego podras agarrar otra carta.\n");
+    pausa_consola(1.3);
+    capturar_coordenada(player, enemy);
+    limpiar_buffer_entrada(); // Limpiar el buffer de entrada para evitar problemas con la entrada del usuario.
+    enter_continuar();
+    mostrar_turno_y_tablero_G(player, enemy);
+    printf("Tablero de guerra actualizado:\n");
+    mostrar_ultimo_disparo_exitoso(player);
+    pausa_consola(1);
+    printf("Presiona enter para sacar otra carta.\n");
+    sacar_carta(player, enemy);
+}
+
+void funcion_carta_11(struct player *player, struct player *enemy) {
+    printf("Puedes mover un barco hacia adelante");
+    pausa_consola(1.3);
+    solicitar_barco(player, enemy);
+    limpiar_buffer_entrada(); // Limpiar el buffer de entrada para evitar problemas con la entrada del usuario.
+    enter_continuar();
+    mostrar_turno_y_tablero(player);
+    printf("Posicion de barco actualizada:\n");
+    enter_continuar();
+}
\ No newline at end of file
diff --git a/codigo_fuente/src/bs_game.c b/codigo_fuente/src/bs_game.c
new file mode 100644
index 0000000..3d86369
--- /dev/null
+++ b/codigo_fuente/src/bs_game.c
@@ -0,0 +1,161 @@
+#include "bs_game.h"
+
+void partida() {
+    struct player player1, player2;
+
+    printf("Jugador 1:\n");
+    inicializar_jugador(&player1);
+    limpiar_pantalla(); // Limpiar pantalla despues del primer jugador.
+    printf("Jugador 2:\n");
+    inicializar_jugador(&player2);
+    limpiar_pantalla(); // Limpiar la pantalla después de inicializar jugadores.
+    
+    printf("Jugadores:\n");
+    printf("Jugador 1:"); color_txt(INFO_COLOR); printf(" %s\n",player1.name); color_txt(DEFAULT_COLOR);
+    printf("Jugador 2:"); color_txt(INFO_COLOR); printf(" %s\n",player2.name); color_txt(DEFAULT_COLOR);
+    enter_continuar(); // Pausa antes de continuar.
+    
+    // Colocar barcos para el jugador 1.
+    colocar_barcos_jugador(&player1); // Colocar barcos para el jugador 1.
+
+    // Colocar barcos para el jugador 2.
+    printf("Ahora es turno de"); color_txt(INFO_COLOR); printf(" %s\n", player2.name); color_txt(DEFAULT_COLOR);
+    enter_continuar(); // Pausa antes de continuar.
+
+    colocar_barcos_jugador(&player2);
+
+    // Elegir aleatoriamente quién inicia
+    decidir_primer_turno(&player1, &player2);
+    Sleep(1000);
+    enter_continuar();
+
+    struct player *jugador_actual, *jugador_enemigo;
+    if(player1.turno == 1) {
+        jugador_actual = &player1;
+        jugador_enemigo = &player2;
+    } else {
+        jugador_actual = &player2;
+        jugador_enemigo = &player1;
+    }
+
+    // Bucle principal del juego
+    do {
+
+        menu_por_turno(jugador_actual, jugador_enemigo);
+    
+        // Despues de acabar el turno, se muestra mensaje de que el turno ha terminado.
+        printf("Tu turno ha terminado.\n");
+        enter_continuar(); // Pausa antes de continuar.
+        
+        // Mensaje de cambio de turno
+        printf("Ahora es turno de %s\n", jugador_enemigo->name);
+        enter_continuar();
+
+
+        // Alternar punteros (esto es lo que realmente cambia el turno)
+        struct player *temp = jugador_actual;
+        jugador_actual = jugador_enemigo;
+        jugador_enemigo = temp;
+        jugador_actual->aciertos_por_turno = 0; // Reiniciar aciertos por turno
+        jugador_actual->last_successful_shot_columna = -1; // Reiniciar disparo exitoso
+        jugador_actual->last_successful_shot_fila = -1; // Reiniciar disparo exitoso
+        jugador_actual->last_card_id = -1; // Reiniciar ID de carta
+    } while(jugador_actual->enemy_hit_parts < VICTORYCONDITION && jugador_enemigo->enemy_hit_parts < VICTORYCONDITION);
+
+    // Mensaje de victoria
+    if(jugador_actual->enemy_hit_parts >= VICTORYCONDITION) {
+            printf("%s ha ganado!\n", jugador_actual->name);
+        } else if(jugador_enemigo->enemy_hit_parts >= VICTORYCONDITION) {
+            printf("%s ha ganado!\n", jugador_enemigo->name);
+        }
+    liberar_flota(&player1); // Liberar memoria de la flota del jugador 1.
+	liberar_flota(&player2); // Liberar memoria de la flota del jugador 2.
+
+}
+
+void menu_por_turno(struct player *player, struct player *enemy) {
+    char opc = ' ';
+    bool loop = true;
+    do {
+    mostrar_turno_y_tablero_G(player, enemy);
+    printf("\n");
+        // Menu de opciones por turno.
+    printf("Elija la opcion que desea realizar:\n");
+    printf("[A]: Reporte de barcos enemigos\n");
+    printf("[B]: Reporte de flota\n");
+    printf("[C]: Sacar carta\n");
+
+    scanf(" %c", &opc);
+    limpiar_buffer_entrada(); // Limpiar el buffer de entrada antes de procesar la opción.
+    opc = toupper(opc); // Convertir a mayúscula para evitar problemas de comparación.
+        switch(opc) {
+            case 'A':
+                limpiar_pantalla(); //limpiar pantalla al salir del menu.
+                imprimirReporteBarcosEnemigos(player, enemy);
+                break;
+            case 'B':
+                limpiar_pantalla(); //limpiar pantalla al salir del menu.
+                imprimirReporteBarcos(player, enemy);
+                break;
+            case 'C':
+                limpiar_pantalla(); //limpiar pantalla al salir del menu.
+                sacar_carta(player, enemy);
+                loop = false;
+                break;
+            default:
+                color_txt(ERROR_COLOR);
+                printf("¡Tecla invalida!\n");
+                color_txt(DEFAULT_COLOR);
+        }
+        limpiar_pantalla(); // Limpiar la pantalla después de cada opción.
+    }while(loop);
+}
+
+void sacar_carta(struct player *player, struct player *enemy) {
+    int carta_id = obtener_id_aleatoria(player);
+    player->last_card_id = carta_id; // Guardar el ID de la carta utilizada
+
+    if (carta_id != 11) mostrar_turno_y_tablero_G(player, enemy); // Mostrar el tablero de guerra si la carta no es la 11
+    else mostrar_turno_y_tablero(player); // Mostrar el tablero normal si la carta es la 11
+    
+    mostrar_info_carta(&player->cartas[carta_id]);
+
+    switch (carta_id) {
+    case 0:
+        funcion_carta_0(player, enemy); // Carta 0: Dispara 1 tiro
+        break;
+    case 1:
+        funcion_carta_1(player, enemy); // Carta 1: Dispara 2 tiros
+        break;
+    case 2:
+        funcion_carta_2(player, enemy); // Carta 2: Dispara 3 tiros
+        break;
+    case 3:
+        funcion_carta_3(player, enemy); // Carta 3: Bombardeo en fila
+        break;
+    case 4: 
+        funcion_carta_4(player, enemy); // Carta 4: Bombardeo en columna
+        break;
+    case 5:
+        funcion_carta_5(player, enemy); // Carta 5: Revela una celda enemiga
+        break;
+    case 6: 
+        funcion_carta_6(player, enemy); // Carta 6: Revela una fila enemiga
+        break;
+    case 7:
+        funcion_carta_7(player, enemy); // Carta 7: Revela una columna enemiga
+        break;
+    case 8:
+        funcion_carta_8(player); // Carta 8: Activa el modo salvo
+        break;
+    case 9:
+        funcion_carta_9(player, enemy); // Carta 9: Activa la torre de ventaja al acumular 4 torres
+        break;
+    case 10:
+        funcion_carta_10(player, enemy); // Carta 10: Dipara 1 tiro y toma otra carta
+        break;
+    case 11:
+        funcion_carta_11(player, enemy); // Carta 11: Mueve un barco hacia adelante
+        break;
+    }
+}
\ No newline at end of file
diff --git a/codigo_fuente/src/bs_logic.c b/codigo_fuente/src/bs_logic.c
new file mode 100644
index 0000000..c8bb1b5
--- /dev/null
+++ b/codigo_fuente/src/bs_logic.c
@@ -0,0 +1,136 @@
+#include "bs_logic.h"
+
+bool procesar_coordenadas(struct player *player, int index, int filaInicio, int filaFin, int columnaInicio, int columnaFin) {
+    bool validacion = false;
+
+        // Validar orientación de las coordenadas
+        if (validar_orientacion(player, index, filaInicio, filaFin, columnaInicio, columnaFin)) validacion = true;
+
+        // Validar dimensión de las coordenadas
+        if (validar_dimension(player, index, filaInicio, filaFin, columnaInicio, columnaFin)) validacion = true;
+
+        // Validar solapamiento de las coordenadas
+        if (validar_solapamiento(player, index, filaInicio, filaFin, columnaInicio, columnaFin)) validacion = true;
+
+    return validacion;
+}
+
+void colocar_barco_en_tablero(struct player *player, int index, int filaInicio, int filaFin, int columnaInicio, int columnaFin) {
+    int i, idx = 0;
+
+    // Solo almacena la información en ship_i->status
+    switch (player->ships[index].direction) {
+        case 'E':
+            for (i = columnaInicio; i <= columnaFin; i++, idx++) {
+                player->ships[index].status[idx][CC_FILA] = filaInicio;
+                player->ships[index].status[idx][CC_COLUMNA] = i;
+                player->ships[index].status[idx][CC_STATUS] = (idx == 0) ? SHIP_STER : SHIP_BODY;
+            }
+            break;
+        case 'O':
+            for (i = columnaInicio; i >= columnaFin; i--, idx++) {
+                player->ships[index].status[idx][CC_FILA] = filaInicio;
+                player->ships[index].status[idx][CC_COLUMNA] = i;
+                player->ships[index].status[idx][CC_STATUS] = (idx == 0) ? SHIP_STER : SHIP_BODY;
+            }
+            break;
+        case 'S':
+            for (i = filaInicio; i <= filaFin; i++, idx++) {
+                player->ships[index].status[idx][CC_FILA] = i;
+                player->ships[index].status[idx][CC_COLUMNA] = columnaInicio;
+                player->ships[index].status[idx][CC_STATUS] = (idx == 0) ? SHIP_STER : SHIP_BODY;
+            }
+            break;
+        case 'N':
+            for (i = filaInicio; i >= filaFin; i--, idx++) {
+                player->ships[index].status[idx][CC_FILA] = i;
+                player->ships[index].status[idx][CC_COLUMNA] = columnaInicio;
+                player->ships[index].status[idx][CC_STATUS] = (idx == 0) ? SHIP_STER : SHIP_BODY;
+            }
+            break;
+    }
+}
+
+void decidir_primer_turno(struct player *player1, struct player *player2) {
+    int primer_turno = (rand() % 2) + 1;
+    printf("Decidiendo quien sera el primer jugador de forma aleatoria...\n");
+    Sleep(1000);
+
+    if (primer_turno == 1) {
+        player1->turno = 1;
+        player2->turno = 2;
+        color_txt(INFO_COLOR); printf("%s ", player1->name); color_txt(DEFAULT_COLOR); printf("ha sido elegido para comenzar la partida\n");
+        color_txt(INFO_COLOR); printf("%s ", player2->name); color_txt(DEFAULT_COLOR); printf("sera el segundo en jugar\n");
+    } else {
+        player2->turno = 1;
+        player1->turno = 2;
+        color_txt(INFO_COLOR); printf("%s ", player2->name); color_txt(DEFAULT_COLOR); printf("ha sido elegido para comenzar la partida\n");
+        color_txt(INFO_COLOR); printf("%s ", player1->name); color_txt(DEFAULT_COLOR); printf("sera el segundo en jugar\n");
+    }
+}
+
+int obtener_id_aleatoria(struct player *player) {
+    // Recalcular probabilidades antes de sacar una carta
+    player->peso_total = calcular_peso_total(player);
+    if(player->peso_total <= 0) {
+        return -1; // No hay cartas disponibles
+    }
+    
+    // Numero aleatorio entre 0 y peso_total
+    int numero_rand = rand() % player->peso_total;
+    
+    int acumulado = 0;
+    for (int i = 0; i < NUM_CARTAS; i++) {
+        acumulado += player->cartas[i].peso;
+        if (numero_rand < acumulado) {
+            return i;
+        }
+    }
+    return -1; // No se encontró una carta válida
+}
+
+int calcular_peso_total(struct player *player) {
+    int peso_total = 0;
+    for (int i = 0; i < NUM_CARTAS; i++) {
+        peso_total += player->cartas[i].peso;
+    }
+    return peso_total;
+}
+
+bool validar_movimiento(struct player *player_i, struct ship *ship_i) {
+    int dx = 0, dy = 0;
+    int nx, ny;
+    int s, k;
+    switch(ship_i->direction) {
+        case 'E': dy =  1; break;
+        case 'O': dy = -1; break;
+        case 'N': dx =  1; break;
+        case 'S': dx = -1; break;
+        default: return false;
+    }
+    nx = ship_i->status[0][CC_FILA] + dx;
+    ny = ship_i->status[0][CC_COLUMNA] + dy;
+
+    // Validar rango en la matriz
+    if(nx < 0 || ny < 0 || nx >= BOARD_SIZE || ny >= BOARD_SIZE) {
+        return false;
+    }
+
+    // Validar solapamiento con otro barco
+    for(s = 0; s < NUM_SHIPS; s++){
+        for(k = 0; k < player_i->ships[s].size; k++) {
+            if(player_i->ships[s].status[k][CC_FILA] == nx && player_i->ships[s].status[k][CC_COLUMNA] == ny) {
+                return false;
+            }
+        }
+    }
+
+    // Validar salud del barco
+    for(int p = 0; p < ship_i->size; p++) {
+        if(ship_i->status[p][CC_STATUS] == SHIP_BODY_D || ship_i->status[p][CC_STATUS] == SHIP_STER_D) {
+            return false;
+        }
+    }
+    return true;
+}
+
diff --git a/codigo_fuente/src/bs_player.c b/codigo_fuente/src/bs_player.c
new file mode 100644
index 0000000..3c3d6c4
--- /dev/null
+++ b/codigo_fuente/src/bs_player.c
@@ -0,0 +1,124 @@
+#include "bs_player.h" // Incluye definiciones de jugador
+
+void inicializar_jugador(struct player *player) {
+
+    // Asignar el nombre al jugador, validando que no sea vacío y no exceda 20 caracteres.
+    player->name[0] = '\0'; // Inicializar el nombre como cadena vacía
+    solicitar_nombre(player);
+
+    // Inicializar estado de jugador.
+    player->placed_ships = 0;
+    player->turno = -1; // Turno inicial del jugador
+    
+    // Variables para barcos.
+    inicializar_flota(player);
+    player->enemy_hit_parts = 0;
+    player->sunked_ships = 0;
+    
+    // Variables para cartas.
+    inicializar_cartas(player); // Asignar informacion y pesos
+    player->torres_acumuladas = 0;
+    for (int i = 0; i < BOARD_SIZE; i++) { // chequeo_fila y chequeo_columna inicializados a false.
+        player->chequeo_fila[i] = false;
+        player->chequeo_columna[i] = false;
+        player->contador_fila[i] = 0;
+        player->contador_columna[i] = 0;
+    }
+    player->ultima_fila_chequeada = -1; // Inicializar fila chequeada a -1
+    player->ultima_columna_chequeada = -1; // Inicializar columna chequeada a -1
+    player->salvo = false;
+    player->buff = false;
+    
+    // Variables de tipo buffer.
+    player->last_input_fila = -1;
+    player->last_input_columna = -1;
+    player->last_successful_shot_fila = -1;
+    player->last_successful_shot_columna = -1;
+    player->last_card_id = -1;
+    player->aciertos_por_turno = 0; // Inicializar aciertos por turno a 0
+}
+
+void inicializar_cartas(struct player *player) {
+    // Inicializar cartas con sus IDs, nombres, probabilidades y descripciones
+    player->peso_total = 0; // Inicializar peso total a 0
+    for (int i = 0; i < NUM_CARTAS; i++) {
+        player->cartas[i].id = i; // Asignar ID a la carta base 0
+        switch (i) {
+            case 0:
+                strcpy(player->cartas[i].nombre, "Dispara 1 tiro");
+                strcpy(player->cartas[i].descripcion, "Inserta coordenadas donde desees disparar.");
+                player->cartas[i].peso = 7;
+                break;
+            case 1:
+                strcpy(player->cartas[i].nombre, "Dispara 2 tiros");
+                strcpy(player->cartas[i].descripcion, "Inserta coordenadas donde desees disparar. Hazlo de nuevo.");
+                player->cartas[i].peso = 5;
+                break;
+            case 2:
+                strcpy(player->cartas[i].nombre, "Dispara 3 tiros");
+                strcpy(player->cartas[i].descripcion, "Inserta coordenadas donde desees disparar. Hazlo dos veces mas.");
+                player->cartas[i].peso = 2;
+                break;
+            case 3:
+                strcpy(player->cartas[i].nombre, "Bombardea una fila");
+                strcpy(player->cartas[i].descripcion, "Si tienes tu buque de 4 casillas a flote, elige un numero y bombardea esa fila entera.");
+                player->cartas[i].peso = 1;
+                break;
+            case 4:
+                strcpy(player->cartas[i].nombre, "Bombardea una columna");
+                strcpy(player->cartas[i].descripcion, "Si tienes tu buque de 5 casillas a flote, elige una letra y bombardea esa columna entera.");
+                player->cartas[i].peso = 1;
+                break;
+            case 5:
+                strcpy(player->cartas[i].nombre, "Revela");
+                strcpy(player->cartas[i].descripcion, "Tu equipo de inteligencia logro descifrar la ubicacion de una parte de un barco.");
+                player->cartas[i].peso = 1;
+                break;
+            case 6:
+                strcpy(player->cartas[i].nombre, "Chequeo fila");
+                strcpy(player->cartas[i].descripcion, "Tu equipo logro activar el sonar. Elige un numero y podras ver el numero de coordenadas en esa fila.");
+                player->cartas[i].peso = 1;
+                break;
+            case 7:
+                strcpy(player->cartas[i].nombre, "Chequeo columna");
+                strcpy(player->cartas[i].descripcion, "Tu equipo logro activar el sonar. Elige una letra y podras ver el numero de coordenadas en esa columna.");
+                player->cartas[i].peso = 1;
+                break;
+            case 8:
+                strcpy(player->cartas[i].nombre, "Salvo");
+                strcpy(player->cartas[i].descripcion, "Esta carta activa el modo Salvo. Dispara los mismos tiros que tengas en flota.");
+                player->cartas[i].peso = 1;
+                break;
+            case 9:
+                strcpy(player->cartas[i].nombre, "Torre de ventaja");
+                strcpy(player->cartas[i].descripcion, "Acumula 4 tarjetas como esta para hundir instantaneamente los barcos.");
+                player->cartas[i].peso = 4;
+                break;
+            case 10:
+                strcpy(player->cartas[i].nombre, "Tira y toma");
+                strcpy(player->cartas[i].descripcion, "Inserta coordenadas donde desees disparar y vuelve a generar una carta.");
+                player->cartas[i].peso = 1;
+                break;
+            case 11:
+                strcpy(player->cartas[i].nombre, "Mover hacia adelante");
+                strcpy(player->cartas[i].descripcion, "Tu equipo logro obtener materiales para arreglar un motor momentaneamente.");
+                player->cartas[i].peso = 1;
+                break;
+        }
+        player->peso_total += player->cartas[i].peso;
+    }
+}
+
+void reset_input(struct player *player_i) {
+    player_i->last_input_fila = -1;
+    player_i->last_input_columna = -1;
+}
+
+void reset_sucessful_shot(struct player *player_i) {
+    player_i->last_successful_shot_fila = -1;
+    player_i->last_successful_shot_columna = -1;
+}
+
+void reset_card_id(struct player *player_i) {
+    player_i->last_card_id = -1;
+}
\ No newline at end of file
diff --git a/codigo_fuente/src/bs_ship.c b/codigo_fuente/src/bs_ship.c
new file mode 100644
index 0000000..0135c39
--- /dev/null
+++ b/codigo_fuente/src/bs_ship.c
@@ -0,0 +1,110 @@
+
+#include "bs_ship.h" // Incluye definiciones de barcos
+
+void inicializar_flota(struct player *player) {
+    // Inicializar barcos del jugador
+    for (int idx_ship = 0; idx_ship < NUM_SHIPS; idx_ship++) {
+        player->ships[idx_ship].id = idx_ship; // Asignar ID del barco
+        switch (idx_ship) {
+            case 0:
+                strcpy(player->ships[idx_ship].name, "Portaaviones");
+                inicializar_barco(&player->ships[idx_ship], 5); // Inicializar barco de 5 partes
+                break;
+            case 1:
+                strcpy(player->ships[idx_ship].name, "Acorazado");
+                inicializar_barco(&player->ships[idx_ship], 4); // Inicializar barco de 4 partes
+                break;
+            case 2:
+                strcpy(player->ships[idx_ship].name, "Crucero");
+                inicializar_barco(&player->ships[idx_ship], 3); // Inicializar barco de 3 partes
+                break;
+            case 3:
+                strcpy(player->ships[idx_ship].name, "Destructor");
+                inicializar_barco(&player->ships[idx_ship], 3); // Inicializar barco de 3 partes
+                break;
+            case 4:
+                strcpy(player->ships[idx_ship].name, "Fragata");
+                inicializar_barco(&player->ships[idx_ship], 2); // Inicializar barco de 2 partes
+                break;
+        }
+    }
+}
+
+void inicializar_barco(struct ship *barco, int size) {
+    barco-> size = size;
+    barco->direction = 'U'; // No definido
+    barco->vivo = true; // Barco está vivo al inicio
+
+    // Reservar memoria para el estado del barco.
+    barco->status = (int **)malloc(size * sizeof(int *));
+    for (int s_part = 0; s_part < size; s_part++) {
+        barco->status[s_part] = (int *)malloc(3 * sizeof(int)); // 3 columnas para x, y y estado
+        barco->status[s_part][CC_FILA] = -1; // Inicializar coordenadas x a -1
+        barco->status[s_part][CC_COLUMNA] = -1; // Inicializar coordenadas y a -1
+        barco->status[s_part][CC_STATUS] = 0; // Inicializar estado a 0 (agua)
+    }
+}
+
+bool posicion_barco(struct player *player, int index, int s_part, int fila, int columna) {
+    // Verifica si la parte del barco esta en la posicion (x, y)
+    return player->ships[index].status[s_part][0] == fila
+        && player->ships[index].status[s_part][1] == columna;
+}
+
+bool posicion_barco_enemy(struct player *player, int index, int s_part, struct player *enemy) {
+    return enemy->ships[index].status[s_part][CC_FILA] == player->last_input_fila
+        && enemy->ships[index].status[s_part][CC_COLUMNA] == player->last_input_columna;
+}
+
+bool casilla_saludable(struct player *enemy, int index, int s_part) {
+    return enemy->ships[index].status[s_part][CC_STATUS] == SHIP_STER || enemy->ships[index].status[s_part][CC_STATUS] == SHIP_BODY;
+}
+
+void hundir_barco_buff(struct player *player, int index, struct player *enemy) {
+    for (int s_part = 0; s_part < enemy->ships[index].size; s_part++) {
+        if (casilla_saludable(enemy, index, s_part)) {
+            enemy->ships[index].status[s_part][CC_STATUS] += 2; // Cambiar estado a dañado
+            player->enemy_hit_parts++; // Incrementar partes alcanzadas
+            player->aciertos_por_turno++; // Incrementar aciertos por turno
+        }
+    }
+    hundido(player, enemy); // Verifica si el barco está hundido
+}
+
+void hundido(struct player *player, struct player *enemy) {
+    for (int i = 0; i < NUM_SHIPS; i++) {
+        if (enemy->ships[i].vivo) {
+            bool hundido = true;
+            for (int j = 0; j < enemy->ships[i].size; j++) {
+                if (enemy->ships[i].status[j][2] != 3 && enemy->ships[i].status[j][2] != 4) {
+                    hundido = false; // Si alguna parte no está dañada, no se hunde
+                    break;
+                }
+            }
+            if (hundido) {
+                enemy->ships[i].vivo = false; // Barco hundido
+                player->sunked_ships++;
+                printf("El barco %d ha sido hundido.\n", i + 1);
+                // Desactivar salvo si estaba activo
+                if (enemy->salvo) {
+                    enemy->salvo = false;
+                    printf("El barco %d ha sido hundido, el modo Salvo enemigo se desactiva.\n", i + 1);
+                }
+            }
+        }
+    }
+}
+
+void liberar_status(struct ship *barco) {
+    for (int i = 0; i < barco->size; i++) {
+        free(barco->status[i]);
+    }
+    free(barco->status);
+    barco->status = NULL; // Evitar puntero colgante
+}
+
+void liberar_flota(struct player *player) {
+    for (int i = 0; i < NUM_SHIPS; i++) {
+        liberar_status(&player->ships[i]);
+    }
+}
\ No newline at end of file
diff --git a/codigo_fuente/src/bs_ui.c b/codigo_fuente/src/bs_ui.c
new file mode 100644
index 0000000..d9abccb
--- /dev/null
+++ b/codigo_fuente/src/bs_ui.c
@@ -0,0 +1,833 @@
+#include "bs_ui.h" // libreria para poder usar funciones de UI.
+
+void pantalla_bienvenida() {
+    // Logo para la pantalla de inicio.
+	printf(" _______  _______  _______  _______  ___      ___      _______    __    _  _______  __   __  _______  ___     \n");
+	printf("|  _    ||   _   ||       ||   _   ||   |    |   |    |   _   |  |  |  | ||   _   ||  | |  ||   _   ||   |    \n");
+	printf("| |_|   ||  |_|  ||_     _||  |_|  ||   |    |   |    |  |_|  |  |   |_| ||  |_|  ||  |_|  ||  |_|  ||   |    \n");
+	printf("|       ||       |  |   |  |       ||   |    |   |    |       |  |       ||       ||       ||       ||   |    \n");
+	printf("|  _   | |       |  |   |  |       ||   |___ |   |___ |       |  |  _    ||       ||       ||       ||   |___ \n");
+	printf("| |_|   ||   _   |  |   |  |   _   ||       ||       ||   _   |  | | |   ||   _   | |     | |   _   ||       | \n");
+	printf("|_______||__| |__|  |___|  |__| |__||_______||_______||__| |__|  |_|  |__||__| |__|  |___|  |__| |__||_______| \n");
+
+	printf("Presiona enter para"); color_txt(INFO_COLOR); printf(" continuar\n"); color_txt(DEFAULT_COLOR);
+	getchar(); // Espera a que el usuario presione una tecla.
+}
+
+void menu_principal() {
+    char opc;
+    bool loop = true;
+
+    limpiar_pantalla(); // Limpiar la pantalla antes de mostrar el menú.
+	// Menu de opciones inicial.
+	do{
+		printf("Ingrese la opcion que desee realizar.\n");
+		printf("Opciones:\n");
+		printf("[A]: Iniciar partida\n");
+        printf("[B]: Ver reglas.\n");
+        printf("[C]: Salir\n");
+		scanf(" %c", &opc);
+        limpiar_buffer_entrada(); // Limpiar el buffer de entrada
+        opc = toupper(opc); // Convertir a mayúscula para evitar problemas de comparación.
+        if (opc == 'A' || opc == 'B' || opc == 'C') {
+            limpiar_pantalla(); // Limpiar la pantalla antes de mostrar el menú.
+        }
+		switch(opc) {
+		    // Caso en el que el usuario quiere iniciar partida.
+            case 'A':
+                partida();
+                break;
+            // caso en el que el usuario quiere leer las reglas.
+            case 'B':
+                reglas();
+                break;
+            // Caso en el que el usuario quiere salir del programa (se especifica con un "case" porque sino el programa imprime "tecla invalida" cuando se presiona la c).
+            case 'C':
+                printf("Gracias por haber usado el programa :)");
+                loop = false;
+                break;
+            default:
+                puts("¡Tecla invalida!");
+                Sleep(1000); // funcion para tener demora en la ejecucion de la limpieza de la terminal.
+                limpiar_pantalla(); // Limpiar la pantalla.
+                break;
+            }
+	}while(loop); // Mientras loop sea verdadero, el menu se repetira.
+}
+
+void reglas() {
+    char opc;
+    do {
+        color_txt(INFO_COLOR);
+        printf("=== REGLAS DEL JUEGO \"BATALLA NAVAL\" ===\n\n");
+        color_txt(DEFAULT_COLOR);
+
+        color_txt(SUCCESS_COLOR);
+        printf("1. Cada jugador contara con una flota de barcos,\n");
+        color_txt(DEFAULT_COLOR);
+        printf("   la cual ordenara en una distribucion que considere conveniente para ocultarla de su rival.\n\n");
+
+        color_txt(SUCCESS_COLOR);
+        printf("2. El juego es por turnos.\n");
+        color_txt(DEFAULT_COLOR);
+        printf("   En cada turno se le proporcionara a cada jugador la posibilidad de usar una ");
+        color_txt(INFO_COLOR); printf("carta"); color_txt(DEFAULT_COLOR);
+        printf(" con diversos efectos sobre el tablero.\n\n");
+
+        color_txt(SUCCESS_COLOR);
+        printf("3. Las cartas disponibles son:\n");
+        color_txt(DEFAULT_COLOR);
+        printf("   ");
+        color_txt(INFO_COLOR); printf("- Disparo: "); color_txt(DEFAULT_COLOR);
+        printf("Dispara a una coordenada del tablero enemigo.\n   ");
+        color_txt(INFO_COLOR); printf("- Bombardeo de fila: "); color_txt(DEFAULT_COLOR);
+        printf("Bombardea una fila del tablero enemigo.\n   ");
+        color_txt(INFO_COLOR); printf("- Bombardeo de columna: "); color_txt(DEFAULT_COLOR);
+        printf("Bombardea una columna del tablero enemigo.\n   ");
+        color_txt(INFO_COLOR); printf("- Revelar: "); color_txt(DEFAULT_COLOR);
+        printf("Revela el estado de los barcos enemigos.\n   ");
+        color_txt(INFO_COLOR); printf("- Chequeo de fila: "); color_txt(DEFAULT_COLOR);
+        printf("Revela el estado de una fila del tablero enemigo.\n   ");
+        color_txt(INFO_COLOR); printf("- Chequeo de columna: "); color_txt(DEFAULT_COLOR);
+        printf("Revela el estado de una columna del tablero enemigo.\n   ");
+        color_txt(INFO_COLOR); printf("- Salvo: "); color_txt(DEFAULT_COLOR);
+        printf("Permite disparar a una coordenada del tablero enemigo sin que el enemigo pueda defenderse.\n   ");
+        color_txt(INFO_COLOR); printf("- Torre de ventaja: "); color_txt(DEFAULT_COLOR);
+        printf("Permite disparar a una coordenada y revela el estado de la fila y columna del barco.\n   ");
+        color_txt(INFO_COLOR); printf("- Revelar casilla aleatoria: "); color_txt(DEFAULT_COLOR);
+        printf("Permite revelar una casilla aleatoria en la que haya un barco enemigo.\n\n");
+
+        color_txt(SUCCESS_COLOR);
+        printf("4. El objetivo del juego es ");
+        color_txt(INFO_COLOR); printf("hundir todos los barcos del enemigo"); color_txt(DEFAULT_COLOR);
+        printf(" antes de que el enemigo hunda los tuyos.\n\n");
+
+        color_txt(SUCCESS_COLOR);
+        printf("5. Un barco se considera hundido cuando ");
+        color_txt(INFO_COLOR); printf("todas sus partes han sido alcanzadas."); color_txt(DEFAULT_COLOR);
+        printf("\n\n");
+
+        color_txt(ERROR_COLOR);
+        printf(" PROHIBIDO\n");
+        color_txt(DEFAULT_COLOR);
+        printf("   ");
+        color_txt(ERROR_COLOR); printf("- No puedes colocar barcos fuera del tablero.\n"); color_txt(DEFAULT_COLOR);
+        printf("   ");
+        color_txt(ERROR_COLOR); printf("- No puedes sobreponer barcos.\n"); color_txt(DEFAULT_COLOR);
+        printf("   ");
+        color_txt(ERROR_COLOR); printf("- No puedes disparar dos veces a la misma casilla.\n"); color_txt(DEFAULT_COLOR);
+        printf("   ");
+        color_txt(ERROR_COLOR); printf("- No puedes mover barcos una vez colocados.\n\n"); color_txt(DEFAULT_COLOR);
+
+        color_txt(INFO_COLOR);
+        printf("Consejos:\n");
+        color_txt(DEFAULT_COLOR);
+        printf("   - Piensa estrategicamente la ubicacion de tus barcos.\n");
+        printf("   - Aprovecha las cartas especiales para obtener ventaja.\n");
+        printf("   - Recuerda que la informacion revelada por cartas es temporal.\n\n");
+
+        printf("[Z]: Regresar al"); color_txt(INFO_COLOR); printf(" menu.\n");
+        color_txt(DEFAULT_COLOR);
+
+        scanf(" %c", &opc);
+        limpiar_buffer_entrada();
+        opc = toupper(opc);
+    } while (opc != 'Z');
+    
+    menu_principal();
+}
+
+void solicitar_nombre(struct player *player) {
+    do {
+        printf("Introduce el nombre del jugador (max 20 caracteres): ");
+        if (fgets(player->name, sizeof(player->name), stdin) == NULL) {
+            color_txt(ERROR_COLOR);
+            printf("Error de entrada. Intenta de nuevo.\n");
+            color_txt(DEFAULT_COLOR);
+            continue;
+        }
+
+        // Si no hay salto de línea, limpiar el buffer y repetir
+        if (strchr(player->name, '\n') == NULL) {
+            int c;
+            while ((c = getchar()) != '\n' && c != EOF); // Limpiar buffer completamente
+            color_txt(ERROR_COLOR);
+            printf("El nombre no puede tener mas de 20 caracteres. Intenta de nuevo.\n");
+            color_txt(DEFAULT_COLOR);
+            continue;
+        }
+
+        // Eliminar salto de línea
+        player->name[strcspn(player->name, "\n")] = '\0';
+
+        // Validar longitud
+        size_t len = strlen(player->name);
+        if (len == 0) {
+            color_txt(ERROR_COLOR);
+            printf("El nombre no puede estar vacio. Intenta de nuevo.\n");
+            color_txt(DEFAULT_COLOR);
+            continue;
+        }
+        if (len > 20) {
+            color_txt(ERROR_COLOR);
+            printf("El nombre no puede tener mas de 20 caracteres. Intenta de nuevo.\n");
+            color_txt(DEFAULT_COLOR);
+            continue;
+        }
+
+        // Si pasa todas las validaciones, salir del ciclo
+        break;
+    } while (1);
+}
+
+void colocar_barcos_jugador(struct player *player) {
+    printf("Colocando barcos para"); color_txt(INFO_COLOR); printf(" %s\n", player->name); color_txt(DEFAULT_COLOR);
+    for(int idx_ship = 0; idx_ship < NUM_SHIPS; idx_ship++) {
+        limpiar_pantalla();
+        printf("Colocando barcos de"); color_txt(INFO_COLOR); printf(" %s\n", player->name); color_txt(DEFAULT_COLOR);
+        imprimirTablero(player);
+        printf("Coloca tu %s", player->ships[idx_ship].name); color_txt(INFO_COLOR); printf(" (%d ",player->ships[idx_ship].size); color_txt(DEFAULT_COLOR);
+        printf("celdas).\nBarco"); color_txt(INFO_COLOR); printf(" %d ",idx_ship + 1); color_txt(DEFAULT_COLOR);
+        printf("de"); color_txt(INFO_COLOR); printf(" %d\n",NUM_SHIPS); color_txt(DEFAULT_COLOR);
+        ponerBarcos(player, idx_ship);
+    }
+    printf("Colocando barcos de"); color_txt(INFO_COLOR); printf(" %s\n", player->name); color_txt(DEFAULT_COLOR);
+    imprimirTablero(player);
+    printf("Barcos colocados correctamente. \n");
+    Sleep(1000);
+    limpiar_buffer_entrada();
+    enter_continuar();
+    limpiar_pantalla();
+}
+
+void imprimirTablero(struct player *player) {
+    int anchoTablero, relleno, consolaAncho;
+    int i, j, idx_ship, s_part, estado;
+    CONSOLE_SCREEN_BUFFER_INFO csbi;
+    
+    // Obtener ancho de consola
+    consolaAncho = 80; //Por defecto si no es posible
+    if(GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &csbi)) {
+        consolaAncho = csbi.srWindow.Right - csbi.srWindow.Left + 1;
+    }
+
+    // Calculando relleno para centrar
+    anchoTablero = BOARD_SIZE * 2 + 3; // Cada columna ocupa 3 caracteres (" 1 ")
+    relleno = (consolaAncho - anchoTablero) / 2;
+
+    color_txt(INFO_COLOR);
+        printf("%*s Tablero de Flota\n", relleno, "");
+    color_txt(DEFAULT_COLOR);
+    // Encabezado de columnas (1 2 3 ... 10)
+    printf("%*s", relleno,""); // Imprime relleno con espacios para centrar
+    printf("  ");
+    for (int num = 1; num <= BOARD_SIZE; num++) {
+        num < BOARD_SIZE ? printf("%2d", num) : printf(" F");
+    }
+    printf("\n");
+
+    // Dibujar cada fila
+    for (i = 0; i < BOARD_SIZE; i++) {
+        // Encabezado de filas (A B C ... J)
+        printf("%*s%c  ", relleno,"", 'A' +i);
+
+        // Recorrer cada columna
+        for (j = 0; j < BOARD_SIZE; j++) {
+            estado = WATER; // Por defecto el estado es agua
+            
+            // Recorrer cada barco
+            for (idx_ship = 0; idx_ship < NUM_SHIPS && estado == WATER; idx_ship++) {
+                
+                // Recorrer cada parte del barco
+                for (s_part = 0; s_part < player->ships[idx_ship].size; s_part++) {
+
+                    // Comprobar si la parte del barco coincide con la posición actual(i, j).
+                    if (posicion_barco(player, idx_ship, s_part, i, j)) {
+
+                        // Si coincide, asignar el estado correspondiente
+                        estado = player->ships[idx_ship].status[s_part][2];
+                        break; // Salir del bucle s_part
+                    }
+                }
+            }
+
+            // Imprimir el resultado según el estado
+            switch (estado) {
+                case SHIP_STER:
+                    color_txt(SHIP_COLOR);
+                    printf("%c ", STER_PRINT);
+                    color_txt(DEFAULT_COLOR);
+                    break;
+                case SHIP_BODY:
+                    color_txt(SHIP_COLOR);
+                    printf("%c ", BODY_PRINT);
+                    color_txt(DEFAULT_COLOR);
+                    break;
+                case SHIP_STER_D:
+                    color_txt(ERROR_COLOR);
+                    printf("%c ", STER_PRINT);
+                    color_txt(DEFAULT_COLOR);
+                    break;
+                case SHIP_BODY_D:
+                    color_txt(ERROR_COLOR);
+                    printf("%c ", BODY_PRINT);
+                    color_txt(DEFAULT_COLOR);
+                    break;
+                default:
+                    color_txt(WATER_COLOR);
+                    printf("%c ", WATER_PRINT);
+                    color_txt(DEFAULT_COLOR);
+                    break;
+            }
+        }
+        printf("\n");
+    }
+}
+
+void ponerBarcos(struct player *player, int index) {
+    int filaInicio, filaFin, columnaInicio, columnaFin;
+    char filaInicio_c, filaFin_c;
+    bool validacion = false;
+
+    do {
+        // Se le pide al usuario que ingrese las coordenadas iniciales y finales del barco.
+        puts("Coordenada inicial del barco (Fila: letras de A a la J; Columna: numero del 1 al 10): ");
+        printf("Ejemplo:"); color_txt(INFO_COLOR); printf("A 1"); color_txt(DEFAULT_COLOR);
+        printf("\n> ");
+
+        if (scanf(" %c %d", &filaInicio_c, &columnaInicio) != 2) {
+            limpiar_buffer_entrada(); // Limpiar el buffer de entrada
+            color_txt(ERROR_COLOR);
+            printf("Formato de entrada invalido.");
+            color_txt(INFO_COLOR); printf("CodeError: 0\n"); color_txt(DEFAULT_COLOR);
+        } else validacion = true;
+        
+        columnaInicio--; // Ajustar columna a base 0
+
+        filaInicio_c = toupper(filaInicio_c); // Convertir a mayúscula para evitar problemas de comparación
+        filaInicio = filaInicio_c - 'A'; // Convertir letra a índice (A=0, B=1, ..., J=9)
+        if (validar_cc_rango(filaInicio, columnaInicio)) validacion = true; // Validar rango de coordenadas
+        
+        if (!validacion) color_txt(ERROR_COLOR); printf("Intente de nuevo.\n"); color_txt(DEFAULT_COLOR);
+    } while(!validacion);
+    
+    validacion = false; // Reiniciar la validacion para la siguiente entrada
+
+    do {
+        puts("Coordenada final del barco (Fila: letras de A a la J; Columna: numero del 1 al 10): ");
+        printf("Ejemplo:"); color_txt(INFO_COLOR); printf("A 1"); color_txt(DEFAULT_COLOR);
+        printf("\n> ");
+
+        if (scanf(" %c %d", &filaFin_c, &columnaFin) != 2) {
+            limpiar_buffer_entrada(); // Limpiar el buffer de entrada
+            color_txt(ERROR_COLOR);
+            printf("Formato de entrada invalido.");
+            color_txt(INFO_COLOR); printf("CodeError: 0\n"); color_txt(DEFAULT_COLOR);
+        } else validacion = true;
+
+        columnaFin--; // Ajustar columna a base 0
+
+        filaFin_c = toupper(filaFin_c); // Convertir a mayúscula para evitar problemas de comparación
+        filaFin = filaFin_c - 'A'; // Convertir letra a índice (A=0, B=1, ..., J=9)
+        if (validar_cc_rango(filaFin, columnaFin)) validacion = true; // Validar rango de coordenadas
+
+        // Validar barco una vez validadas las coordenadas iniciales y finales.
+        if (procesar_coordenadas(player, index, filaInicio, filaFin, columnaInicio, columnaFin)) validacion = true; // Validaciones en conjunto
+
+        if (!validacion) color_txt(ERROR_COLOR); printf("Intente de nuevo.\n"); color_txt(DEFAULT_COLOR);
+    } while(!validacion);
+    
+    // Si las coordenadas son validas, colocar el barco en el tablero.
+    colocar_barco_en_tablero(player, index, filaInicio, filaFin, columnaInicio, columnaFin);
+    
+    color_txt(SUCCESS_COLOR);
+    printf("Barco colocado exitosamente de");
+    color_txt(INFO_COLOR);
+    printf(" (%c, %d) ", filaInicio_c, columnaInicio + 1);
+    color_txt(DEFAULT_COLOR); printf("a");
+    color_txt(INFO_COLOR); printf(" (%c, %d)\n", filaFin_c, columnaFin + 1); color_txt(DEFAULT_COLOR);
+    Sleep(1000); // Pausa para mostrar el mensaje de éxito.
+    limpiar_pantalla(); // Limpiar la pantalla después de colocar el barco.
+}
+
+void mostrar_turno_y_tablero_G(struct player *player, struct player *enemy) {
+    int espacios = 5; // Espacios para centrar el texto
+
+    printf("Turno de");
+
+    color_txt(INFO_COLOR);
+    printf(" %s %*s", player->name, espacios, "");
+    color_txt(DEFAULT_COLOR);
+
+    printf(" | Modo salvo: ");
+
+    player->salvo ? color_txt(SUCCESS_COLOR) : color_txt(ERROR_COLOR);
+    printf("%s ", player->salvo ? "Activo" : "Inactivo");
+    color_txt(DEFAULT_COLOR);
+    if (player->buff) {
+        printf("| Torre de ventaja: ");
+        
+        color_txt(SUCCESS_COLOR);
+            printf("Activada ");
+        color_txt(DEFAULT_COLOR);
+    } else {
+        printf(" | Torres acumuladas: ");
+
+        color_txt(INFO_COLOR);
+            printf("%d\n\n", player->torres_acumuladas);
+        color_txt(DEFAULT_COLOR);
+    }
+
+    imprimirTableroGuerra(enemy, player); // Imprimir el tablero del enemigo.
+}
+
+void imprimirTableroGuerra(struct player *enemy, struct player *player) {
+    int anchoTablero, relleno, consolaAncho;
+    int i, j, idx_ship, s_part, print_status;
+    CONSOLE_SCREEN_BUFFER_INFO csbi;
+
+    // Obtener ancho de consola
+    consolaAncho = 80; //Por defecto si no es posible
+    if(GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &csbi)) {
+        consolaAncho = csbi.srWindow.Right - csbi.srWindow.Left + 1;
+    }
+
+    // Calculando relleno para centrar
+    anchoTablero = BOARD_SIZE * 3 + 3; // Cada columna ocupa 3 caracteres (" 1 ")
+    relleno = (consolaAncho - anchoTablero) / 2;
+
+    color_txt(INFO_COLOR);
+        printf("%*s Tablero de Guerra\n", relleno, ""); 
+    color_txt(DEFAULT_COLOR);
+    // Encabezado de columnas (1 2 3 ... 10)
+    printf("%*s", relleno,""); // Imprime relleno con espacios para centrar
+    printf("  ");
+    for (int num = 1; num <= BOARD_SIZE; num++) {
+        num < BOARD_SIZE ? printf("%2d", num) : printf(" F");
+    }
+    printf("\n");
+
+    // Dibujar cada fila
+    for (i = 0; i < BOARD_SIZE; i++) {
+
+        // Encabezado de filas (A B C ... J)
+        printf("%*s%c  ", relleno,"", 'A' + i);
+
+        // Recorrer cada columna
+        for (j = 0; j < BOARD_SIZE; j++) {
+            print_status = WATER; // Por defecto el estado es agua
+            for (idx_ship = 0; idx_ship < NUM_SHIPS && print_status == WATER; idx_ship++) {
+                for (s_part = 0; s_part < enemy->ships[idx_ship].size; s_part++) {
+
+                    // Comprobar si la parte del barco coincide con la posición actual(i, j).
+                    if (posicion_barco(enemy, idx_ship, s_part, i, j)) {
+
+                        // Si coincide, asignar el estado correspondiente
+                        if (enemy->ships[idx_ship].status[s_part][CC_STATUS] == SHIP_BODY_D) {
+                            print_status = SHIP_BODY_D;
+                        } else if (enemy->ships[idx_ship].status[s_part][CC_STATUS] == SHIP_STER_D) {
+                            print_status = SHIP_STER_D;
+                        }
+                        break; // Salir del bucle s_part
+                    }
+                }
+            }
+            switch (print_status) {
+                case SHIP_STER_D:
+                    color_txt(ERROR_COLOR);
+                    printf("%c ", STER_PRINT);
+                    color_txt(DEFAULT_COLOR);
+                    break;
+                case SHIP_BODY_D:
+                    color_txt(ERROR_COLOR);
+                    printf("%c ", BODY_PRINT);
+                    color_txt(DEFAULT_COLOR);
+                    break;
+                default:
+                    color_txt(WATER_COLOR);
+                    printf("%c ", WATER_PRINT);
+                    color_txt(DEFAULT_COLOR);
+                    break;
+            }
+        }
+        // Mostrar chequeo de fila al final de la fila solo si está activado
+        if (player->chequeo_fila[i]) {
+            barcos_en_fila(player, enemy);
+            color_txt(SUCCESS_COLOR);
+            if (player->contador_fila[i] > BOARD_SIZE - 1) {
+                printf(" %d", player->contador_fila[i]);
+            } else {
+                printf("F "); // F = Full
+            }
+            color_txt(DEFAULT_COLOR);
+        }
+        printf("\n");
+    }
+
+    // Mostrar chequeo de columna (una sola línea debajo del tablero)
+    printf("%*s   ", relleno, "");
+        for (j = 0; j < BOARD_SIZE; j++) {
+            if (player->chequeo_columna[j]) {
+                barcos_en_columna(player, enemy);
+                color_txt(SUCCESS_COLOR);
+                if (player->contador_columna[j] > BOARD_SIZE - 1) {
+                    printf("%d ", player->contador_columna[j]);    
+                } else {
+                    printf(" F "); // F = Full
+                }
+                color_txt(DEFAULT_COLOR);
+            } else {
+                printf("  "); // Espacio vacío si no hay chequeo
+            }
+        }
+    printf("\n");
+}
+
+void imprimirReporteBarcosEnemigos(struct player *player, struct player *enemy) {
+    
+    mostrar_turno_y_tablero_G(player, enemy);
+    printf("\n");
+    printf("Reporte de barcos enemigos:\n");
+    printf("Barcos enemigos hundidos: ");
+    color_txt(INFO_COLOR);
+        printf("%d\n", player->sunked_ships);
+    color_txt(DEFAULT_COLOR);
+
+    printf("Partes de barcos enemigos hundidos: ");
+    color_txt(INFO_COLOR);
+        printf("%d\n", player->enemy_hit_parts);
+    color_txt(DEFAULT_COLOR);
+
+    printf("Modo salvo enemigo activado: ");
+    enemy->salvo ? color_txt(INFO_COLOR) : color_txt(SUCCESS_COLOR);
+        printf("%s\n", enemy->salvo ? "Si" : "No");
+    color_txt(DEFAULT_COLOR);
+
+    printf("Torre de ventaja enemigo activada: ");
+    enemy->torres_acumuladas == 4 ? color_txt(INFO_COLOR) : color_txt(SUCCESS_COLOR);
+        printf("%s\n", enemy->torres_acumuladas == 4 ? "Si" : "No");
+    color_txt(DEFAULT_COLOR);
+    printf("\n");
+
+    printf("[z]: Regresar al menu.\n");
+    char opc;
+    bool loop = true;
+    do {
+        scanf(" %c", &opc);
+        limpiar_buffer_entrada(); // Limpiar el buffer de entrada
+        opc = toupper(opc);
+        if (opc == 'Z') {
+            loop = false;
+        } else {
+            color_txt(ERROR_COLOR);
+            printf("¡Tecla invalida!\n");
+            color_txt(DEFAULT_COLOR);
+        }
+    } while (loop);
+}
+
+void imprimirReporteBarcos(struct player *player, struct player *enemy) {
+    int i, k;
+    int dimension_maxima = 0;
+    int ancho_col = 12; // Ancho fijo para cada barco
+
+    mostrar_turno_y_tablero(player);
+    printf("\n");
+    printf("Reporte de barcos:\n");
+
+    // Encontrar el tamaño máximo de los barcos
+    for (i = 0; i < NUM_SHIPS; i++) {
+        if (player->ships[i].size > dimension_maxima) {
+            dimension_maxima = player->ships[i].size;
+        }
+    }
+
+    // Encabezado
+    for (i = 0; i < NUM_SHIPS; i++) {
+        printf("%*sBote %02d", ancho_col / 2 - 4, "", i + 1);
+        printf("%*s", ancho_col - (ancho_col / 2 + 4), "");
+    }
+    printf("\n");
+
+    // Dibujo de proa (/'\)
+    for (i = 0; i < NUM_SHIPS; i++) {
+        int estado = player->ships[i].status[0][2];
+        if (i == 0) printf("%*s", ancho_col - 8, "");
+        estado == SHIP_STER ? color_txt(SHIP_COLOR) : color_txt(ERROR_COLOR);
+        printf("/'\\");
+        color_txt(DEFAULT_COLOR);
+        printf("%*s", ancho_col - 4, "");
+    }
+    printf("\n");
+
+    // Cuerpo del barco
+    for (k = 1; k < dimension_maxima; k++) {
+        for (i = 0; i < NUM_SHIPS; i++) {
+            if (k < player->ships[i].size) {
+                int estado = player->ships[i].status[k][2];
+                if (i == 0) printf("%*s", ancho_col - 8, "");
+                if (estado == SHIP_BODY) {
+                    color_txt(SHIP_COLOR);
+                    printf("[_]");
+                } else {
+                    color_txt(ERROR_COLOR);
+                    printf("[X]");
+                }
+                color_txt(DEFAULT_COLOR);
+                printf("%*s", ancho_col - 4, "");
+            } else {
+                printf("%*s", ancho_col, "");
+            }
+        }
+    printf("\n");
+    }
+
+    printf("[Z]: Regresar al menu.\n");
+    char opc;
+    bool loop = true;
+    do {
+        scanf(" %c", &opc);
+        limpiar_buffer_entrada(); // Limpiar el buffer de entrada
+        opc = toupper(opc);
+        if (opc == 'Z') {
+            loop = false;
+        } else {
+            color_txt(ERROR_COLOR);
+            printf("¡Tecla invalida!\n");
+        color_txt(DEFAULT_COLOR);
+    }
+    } while (loop);
+}
+
+void mostrar_turno_y_tablero(struct player *player) {
+    int espacios = 10; // Espacios para centrar el texto
+
+    printf("Turno de");
+
+    color_txt(INFO_COLOR);
+    printf(" %s %*s", player->name, espacios, "");
+    color_txt(DEFAULT_COLOR);
+
+    printf(" | Modo salvo: ");
+
+    player->salvo ? color_txt(SUCCESS_COLOR) : color_txt(ERROR_COLOR);
+    printf("%s ", player->salvo ? "Activado" : "Desactivado");
+    color_txt(DEFAULT_COLOR);
+    if (player->buff) {
+        printf("| Torre de ventaja: ");
+        
+        color_txt(SUCCESS_COLOR);
+            printf("Activada ");
+        color_txt(DEFAULT_COLOR);
+    } else {
+        printf(" | Torres acumuladas: ");
+
+        color_txt(INFO_COLOR);
+            printf("%d\n\n", player->torres_acumuladas);
+        color_txt(DEFAULT_COLOR);
+    }
+    imprimirTablero(player); // Imprimir el tablero del jugador.
+}
+
+void mostrar_info_carta(struct cartas *carta) {
+    printf("Te ha salido la carta:"); color_txt(INFO_COLOR); printf(" %s\n", carta->nombre); color_txt(DEFAULT_COLOR);
+}
+
+void capturar_coordenada(struct player *player, struct player *enemy) {
+    char fila_c;
+    int columna;
+    bool validacion = false;
+    char linea[32]; // Buffer para la entrada del usuario
+    char *nl; // Puntero para el salto de línea
+    do {
+        puts("Ingrese las coordenadas (Fila: letras de A a la J; Columna: numeros del 1 al 10): ");
+        printf("Ejemplo: "); color_txt(INFO_COLOR); printf("A 1\n"); color_txt(DEFAULT_COLOR);
+        printf("> ");
+
+        if(!fgets(linea, sizeof(linea), stdin)) {
+            limpiar_buffer_entrada(); // Limpiar el buffer de entrada
+            color_txt(ERROR_COLOR);
+            printf("Error de entrada."); color_txt(INFO_COLOR); printf(" CodeError: Null.\n");
+            color_txt(DEFAULT_COLOR);
+            continue; // Repetir el ciclo si la entrada es invalida
+        }
+
+        nl = strchr(linea, '\n');
+        if(nl) *nl = '\0'; // Eliminar el salto de línea al final de la entrada
+
+        // Intentar leer las coordenadas en el formato "A 1" o "A1"
+        if (sscanf(linea, " %c %d", &fila_c, &columna) != 2
+          && sscanf(linea, " %c%d", &fila_c, &columna) != 2) {
+            color_txt(ERROR_COLOR);
+            printf("Formato invalido.");
+            color_txt(INFO_COLOR); printf("CodeError: 0\n");
+            color_txt(DEFAULT_COLOR);
+            continue; // Repetir el ciclo si la entrada es invalida
+        }
+        
+        fila_c = toupper(fila_c); // Convertir a mayúscula para evitar problemas de comparación
+        player->last_input_fila = fila_c - 'A';
+        player->last_input_columna = columna - 1; // Ajustar columna a base 0
+
+        // Rango de coordenadas
+        if (!validar_ataque_cc_rango(player)) {
+            continue;
+        } 
+        if (!validar_estado_casilla(player, enemy)) {
+            continue;
+        }
+        validacion = true; // Si todas las validaciones pasan, se marca como valido
+
+        if (!validacion) {
+            color_txt(ERROR_COLOR);
+            printf("Intente de nuevo.\n");
+            color_txt(DEFAULT_COLOR); 
+        }
+    } while (!validacion);
+
+    printf("Coordenadas ingresadas: %c, %d\n", 
+            player->last_input_fila + 'A', 
+            player->last_input_columna + 1);
+
+    disparar(player, enemy);
+}
+
+void mostrar_ultimo_disparo_exitoso(struct player *player) {
+    if (player->last_successful_shot_columna != -1 && player->last_successful_shot_fila != -1) {
+        color_txt(SUCCESS_COLOR);
+        printf("Disparo exitoso en: %c,%d\n", player->last_successful_shot_fila + 'A', player->last_successful_shot_columna + 1);
+        color_txt(DEFAULT_COLOR);
+    } else {
+        printf("No se ha realizado ningun disparo exitoso.\n");
+    }
+}
+
+void capturar_fila_columna(struct player *player, struct player *enemy) {
+    char fila_c;
+    int columna;
+    bool validacion = false;
+
+    if (player->last_card_id == 3 || player->last_card_id == 6) {
+        // Bombardeo/Chequeo de fila: letra
+        do {
+            printf("Ingrese la fila que desee %s (A-%c): ",(player->last_card_id==3) ? "bombardear" : "revisar",'A' + BOARD_SIZE - 1);
+
+            if (scanf(" %c", &fila_c) == 0) {
+                limpiar_buffer_entrada(); // Limpiar el buffer de entrada
+                color_txt(ERROR_COLOR);
+                printf("Error de formato,"); color_txt(INFO_COLOR); printf("CodeError: NULL\n");
+                color_txt(DEFAULT_COLOR);
+            } else validacion = true;
+            fila_c = toupper(fila_c); // Convertir a mayúscula para evitar problemas de comparación
+            player->last_input_fila = fila_c - 'A'; // Convertir letra a índice (A=0, B=1, ..., J=9)
+
+            if (validar_ataque_cc_rango(player)) validacion = true; // Validar rango de coordenadas
+
+        } while (!validacion);
+    } else if (player->last_card_id == 4 || player->last_card_id == 7) {
+        // Bombardeo/Chequeo de columna: número
+        do {
+            printf("Ingrese la columna que desee %s (1-%d): ",(player->last_card_id==4) ? "bombardear" : "revisar",BOARD_SIZE);
+            if(scanf(" %d", &columna) == 0) {
+                limpiar_buffer_entrada(); // Limpiar el buffer de entrada
+                color_txt(ERROR_COLOR);
+                printf("Error de formato,"); color_txt(INFO_COLOR); printf("CodeError: NULL\n");
+                color_txt(DEFAULT_COLOR);
+            } else validacion = true;
+            player->last_input_columna = columna - 1; // Ajustar columna a base 0
+
+            if (validar_ataque_cc_rango(player)) validacion = true; // Validar rango de coordenadas
+
+        } while (!validacion);
+    }
+
+    switch (player->last_card_id) {
+        case 3: 
+            bombardea_fila(player, enemy);
+            break;
+        case 4: 
+            bombardea_columna(player, enemy);
+            break;
+        case 6:
+            chequeo_fila(player, enemy);
+            player->ultima_fila_chequeada = player->last_input_fila;
+            break;
+        case 7:
+            chequeo_columna(player, enemy);
+            player->ultima_columna_chequeada = player->last_input_columna;
+            break;
+    }
+}
+
+void mostrar_bomb_cheq_exitoso(struct player *player_i) {
+        
+switch (player_i->last_card_id) {
+    case 3:
+        if (player_i->last_successful_shot_fila != -1) {
+            printf("Bombardeo exitoso en la fila: %c\n", player_i->last_successful_shot_fila + 'A');
+            printf("Casillas enemigas destruidos: %d\n", player_i->aciertos_por_turno);
+        } else printf("No se ha realizado ningun bombardeo exitoso.\n");
+        break;
+    case 4:
+        if (player_i->last_successful_shot_columna != -1) {
+            printf("Bombardeo exitoso en la columna: %d\n", player_i->last_successful_shot_columna + 1);
+            printf("Casillas enemigas destruidos: %d\n", player_i->aciertos_por_turno);
+        } else printf("No se ha realizado ningun bombardeo exitoso.\n");
+        break;
+    case 6:
+        printf("Chequeo exitoso en la fila: %c\n", player_i->ultima_fila_chequeada + 'A');
+        printf("Casillas enemigas encontradas: %d\n", player_i->contador_fila[player_i->ultima_fila_chequeada]);
+        break;
+    case 7:
+        printf("Chequeo exitoso en la columna: %d\n", player_i->ultima_columna_chequeada + 1);
+        printf("Casillas enemigas encontradas: %d\n", player_i->contador_columna[player_i->ultima_columna_chequeada]);
+        break;
+    }
+}
+
+void solicitar_barco(struct player *player_i, struct player *enemy_i) {
+    int i, barco_seleccionado;
+    char opc;
+    do {
+        limpiar_pantalla();
+        printf("Turno de"); color_txt(INFO_COLOR); printf(" %s\n", player_i->name); color_txt(DEFAULT_COLOR);
+        imprimirTablero(player_i);    
+        printf("Seleccione el barco que desea mover:\n");
+        for (i = 0; i < NUM_SHIPS; i++) {
+            if (validar_movimiento(player_i, &player_i->ships[i])) {
+                // Mostrar solo barcos que se pueden mover
+                printf("Barco %d: %d celdas\n", i + 1, player_i->ships[i].size);
+            }
+        }
+        printf("[z]: No mover ningun barco.\n");
+        scanf(" %c", &opc);
+        opc = toupper(opc);
+        switch (opc) {
+            case 'Z':
+                printf("No se movera ningun barco. Recibes una carta de"); color_txt(INFO_COLOR); printf(" disparo.\n");
+                color_txt(DEFAULT_COLOR);
+                capturar_coordenada(player_i, enemy_i);
+                return;
+            case '1': case '2': case '3': case '4': case '5':
+                barco_seleccionado = opc - '1'; // Convertir a base 0
+                if (validar_movimiento(player_i, &player_i->ships[barco_seleccionado])) {       
+                    mover_barco_adelante(player_i, barco_seleccionado);
+                    return;
+                } else {
+                        color_txt(ERROR_COLOR);
+                    printf("No puedes mover ese barco.\n");
+                    color_txt(DEFAULT_COLOR);
+                    Sleep(2000); // Pausa para mostrar el mensaje de error.
+                    break; // Salir del bucle si el barco no se puede mover
+                }
+                break;
+            default:
+                color_txt(ERROR_COLOR);
+                printf("Opcion invalida. Intente de nuevo.\n");
+                color_txt(DEFAULT_COLOR);
+                Sleep(2000);
+            }
+        } while (1);
+}
+
+
diff --git a/codigo_fuente/src/main.c b/codigo_fuente/src/main.c
new file mode 100644
index 0000000..da80402
--- /dev/null
+++ b/codigo_fuente/src/main.c
@@ -0,0 +1,9 @@
+#include "master.h" // Incluye todas las cabeceras necesarias para el proyecto
+
+int main() {
+	srand((unsigned int)time(NULL)); // Inicializa la semilla para números aleatorios.
+	pantalla_bienvenida(); // Pantalla de bienvenida.
+	menu_principal(); // Menu principal.
+	
+	return 0; // Fin del programa.
+}
\ No newline at end of file
