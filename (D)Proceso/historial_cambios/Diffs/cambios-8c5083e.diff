commit 8c5083eeb28f59ab834a5dc83fe773eb188b0ac3
Author: Isaac Alejandro Ortiz Zaldivar <a24216345@alumnos.uady.mx>
Date:   Sat May 31 01:13:20 2025 -0600

    Refactor game logic and UI for improved player interactions
    
    - Added validation for initial ship overlap in `validar_solapamiento_inicial`.
    - Updated function signatures in `bs_flow_card.h` to include enemy player parameter.
    - Refactored `colocar_barcos_jugador` to `flow_colocar_barcos` for better clarity.
    - Enhanced coordinate processing in `procesar_coordenadas` for streamlined validation.
    - Consolidated repeated code in `funcion_carta_*` functions into `shot_flow` and `end_card_flow`.
    - Improved user input handling in `ponerBarcos` for better UX and error management.
    - Adjusted function parameters across various functions to maintain consistency.
    - Updated descriptions in player card initialization for clarity.

diff --git a/codigo_fuente/include/bs_board.h b/codigo_fuente/include/bs_board.h
index 8c328cc..316dd24 100644
--- a/codigo_fuente/include/bs_board.h
+++ b/codigo_fuente/include/bs_board.h
@@ -7,6 +7,8 @@
 
 bool validar_cc_rango(int cc_fila, int cc_columna);
 
+bool validar_solapamiento_inicial(struct player *player, int index, int filaInicio, int columnaInicio);
+
 bool validar_orientacion(struct player *player, int index, int filaInicio, int filaFin, int columnaInicio, int columnaFin);
 
 bool validar_dimension(struct player *player, int index, int filaInicio, int filaFin, int columnaInicio, int columnaFin);
diff --git a/codigo_fuente/include/bs_flow_card.h b/codigo_fuente/include/bs_flow_card.h
index bde2aed..dea9c26 100644
--- a/codigo_fuente/include/bs_flow_card.h
+++ b/codigo_fuente/include/bs_flow_card.h
@@ -4,6 +4,9 @@
 #include "master.h"
 
 // Prototipos de funciones
+static void shot_flow(struct player *player, struct player *enemy, int count);
+
+static void end_card_flow(struct player *player, struct player *enemy);
 
 void funcion_carta_0(struct player *player, struct player *enemy);
 
@@ -21,12 +24,12 @@ void funcion_carta_6(struct player *player, struct player *enemy);
 
 void funcion_carta_7(struct player *player, struct player *enemy);
 
-void funcion_carta_8(struct player *player);
+void funcion_carta_8(struct player *player, struct player *enemy);
 
-void funcion_carta_9(struct player *player_i, struct player *enemy_i);
+void funcion_carta_9(struct player *player, struct player *enemy);
 
-void funcion_carta_10(struct player *player_i, struct player *enemy_i);
+void funcion_carta_10(struct player *player, struct player *enemy);
 
-void funcion_carta_11(struct player *player_i, struct player *enemy_i);
+void funcion_carta_11(struct player *player, struct player *enemy);
 
 #endif // BS_FLOW_CARD_H
\ No newline at end of file
diff --git a/codigo_fuente/include/bs_logic.h b/codigo_fuente/include/bs_logic.h
index adac3f3..b8c6ecd 100644
--- a/codigo_fuente/include/bs_logic.h
+++ b/codigo_fuente/include/bs_logic.h
@@ -5,7 +5,7 @@
 
 // Prototipos de funciones
 
-bool procesar_coordenadas(struct player *player_i, int index, int filaInicio, int filaFin, int columnaInicio, int columnaFin);
+bool procesar_coordenadas(struct player *player, int index, int filaInicio, int filaFin, int columnaInicio, int columnaFin);
 
 void colocar_barco_en_tablero(struct player *player, int index, int filaInicio, int filaFin, int columnaInicio, int columnaFin);
 
diff --git a/codigo_fuente/include/bs_ui.h b/codigo_fuente/include/bs_ui.h
index 093f3ef..150e400 100644
--- a/codigo_fuente/include/bs_ui.h
+++ b/codigo_fuente/include/bs_ui.h
@@ -13,7 +13,9 @@ void reglas();
 
 void solicitar_nombre(struct player *player);
 
-void colocar_barcos_jugador(struct player *player);
+void tablero_colocar_barcos(struct player *player, int index);
+
+void flow_colocar_barcos(struct player *player);
 
 void imprimirTablero(struct player *player);
 
@@ -21,7 +23,7 @@ void ponerBarcos(struct player *player, int index);
 
 void mostrar_turno_y_tablero_G(struct player *player, struct player *enemy);
 
-void imprimirTableroGuerra(struct player *enemy, struct player *player);
+void imprimirTableroGuerra(struct player *player, struct player *enemy);
 
 void imprimirReporteBarcosEnemigos(struct player *player, struct player *enemy);
 
@@ -33,14 +35,12 @@ void mostrar_info_carta(struct cartas *carta);
 
 void capturar_coordenada(struct player *player, struct player *enemy);
 
-void mostrar_ultimo_disparo_exitoso(struct player *player_i);
-
-void mostrar_bomb_cheq_exitoso(struct player *player_i);
-
+void mostrar_ultimo_disparo_exitoso(struct player *player);
 
+void mostrar_bomb_cheq_exitoso(struct player *player);
 
-void capturar_fila_columna(struct player *player_i, struct player *enemy_i);
+void capturar_fila_columna(struct player *player, struct player *enemy);
 
-void solicitar_barco(struct player *player_i, struct player *enemy_i);
+void solicitar_barco(struct player *player, struct player *enemy);
 
 #endif // BS_UI_H
\ No newline at end of file
diff --git a/codigo_fuente/src/bs_board.c b/codigo_fuente/src/bs_board.c
index 6f1452f..ff92fc7 100644
--- a/codigo_fuente/src/bs_board.c
+++ b/codigo_fuente/src/bs_board.c
@@ -17,14 +17,40 @@ bool validar_cc_rango(int cc_fila, int cc_columna) {
     }
     color_txt(INFO_COLOR); printf(" CodeError: 1\n");
     color_txt(DEFAULT_COLOR);
+    color_txt(ERROR_COLOR);
+    printf("Intente de nuevo.\n");
+    color_txt(DEFAULT_COLOR);
     return false;
 }
 
+bool validar_solapamiento_inicial(struct player *player, int index, int filaInicio, int columnaInicio) {
+    int i, x, y, idx_ship, s_part;
+
+    for (idx_ship = 0; idx_ship < player->placed_ships; idx_ship++) {
+        for (s_part = 0; s_part < player->ships[idx_ship].size; s_part++) {
+            if (posicion_barco(player, idx_ship, s_part, filaInicio, columnaInicio)) {
+                color_txt(ERROR_COLOR);
+                printf("Solapamiento detectado en"); color_txt(INFO_COLOR); printf(" %d,%d", filaInicio, columnaInicio);
+                color_txt(DEFAULT_COLOR); printf(" con el barco %d", idx_ship + 1);
+                color_txt(INFO_COLOR); printf(" CodeError: 4\n"); color_txt(DEFAULT_COLOR);
+                color_txt(ERROR_COLOR);
+                printf("Intente de nuevo.\n");
+                color_txt(DEFAULT_COLOR);
+                return false; // Hay solapamiento
+            }
+        }
+    }
+    return true; // No hay solapamiento
+}
+
 bool validar_orientacion(struct player *player, int index, int filaInicio, int filaFin, int columnaInicio, int columnaFin) {
     if (!(filaInicio == filaFin || columnaInicio == columnaFin)) {
         color_txt(ERROR_COLOR);
         printf("Orientacion no permitida, el barco debe ser horizontal o vertical."); color_txt(INFO_COLOR); printf(" CodeError: 2\n");
         color_txt(DEFAULT_COLOR);
+        color_txt(ERROR_COLOR);
+        printf("Intente de nuevo.\n");
+        color_txt(DEFAULT_COLOR);
         return false;
     } else { // Si la orientación es válida, asignar la dirección.
         if (filaInicio == filaFin) {
@@ -51,6 +77,9 @@ bool validar_dimension( struct player *player, int index, int filaInicio, int fi
         printf("Las coordenadas no son validas. El barco debe tener"); color_txt(INFO_COLOR); printf(" %d", player->ships[index].size);
         color_txt(ERROR_COLOR); printf(" celdas de longitud.", player->ships[index].size); color_txt(INFO_COLOR); printf(" CodeError: 3\n");
         color_txt(DEFAULT_COLOR);
+        color_txt(ERROR_COLOR);
+        printf("Intente de nuevo.\n");
+        color_txt(DEFAULT_COLOR);
         return false;
     }
     return true; // Dimensión válida
@@ -58,41 +87,46 @@ bool validar_dimension( struct player *player, int index, int filaInicio, int fi
 
 bool validar_solapamiento(struct player *player, int index, int filaInicio, int filaFin, int columnaInicio, int columnaFin) {
     int i, x, y, idx_ship, s_part;
-
+    int b_f, b_c;
     // Recorre todas las posiciones que ocuparía el nuevo barco
     if (player->ships[index].direction == 'E' || player->ships[index].direction == 'O') {
         // Horizontal
-        for (i = columnaInicio; (player->ships[index].direction == 'E') ? (i <= columnaFin) : (i >= columnaFin); (player->ships[index].direction == 'E') ? i++ : i--) {
+        for (b_c = columnaInicio; (player->ships[index].direction == 'E') ? (b_c <= columnaFin) : (b_c >= columnaFin); (player->ships[index].direction == 'E') ? b_c++ : b_c--) {
             x = filaInicio;
-            y = i;
+            y = b_c;
             // Compara contra todos los barcos ya colocados
             for (idx_ship = 0; idx_ship < player->placed_ships; idx_ship++) {
                 for (s_part = 0; s_part < player->ships[idx_ship].size; s_part++) {
                     // Solo compara si la casilla ya fue asignada (no -1)
-                    if ((posicion_barco(player, idx_ship, s_part, x, y)) && x != -1 && y != -1) {
+                    if (posicion_barco(player, idx_ship, s_part, x, y)) {
                         color_txt(ERROR_COLOR);
                         printf("Solapamiento detectado en"); color_txt(INFO_COLOR); printf(" %d,%d", x, y); 
                         color_txt(DEFAULT_COLOR); printf(" con el barco %d", idx_ship + 1);
                         color_txt(INFO_COLOR); printf(" CodeError: 4\n"); color_txt(DEFAULT_COLOR);
+                        color_txt(ERROR_COLOR);
+                        printf("Intente de nuevo.\n");
+                        color_txt(DEFAULT_COLOR);
                         return false; // Hay solapamiento
                     }
                 }
             }
         }
     } 
+    else {
     // Vertical
-    else {    
-        for (i = filaInicio; (player->ships[index].direction == 'S') ? (i <= filaFin) : (i >= filaFin); (player->ships[index].direction == 'S') ? i++ : i--) {
-            x = i;
+        for (b_f = filaInicio; player->ships[index].direction == 'S' ? b_f <= filaFin : b_f >= filaFin; player->ships[index].direction == 'S' ? b_f++ : b_f--)
+        {
+            x = b_f;
             y = columnaInicio;
-            for (s_part = 0; s_part < player->ships[idx_ship].size; s_part++) {
-                // Solo compara si la casilla ya fue asignada (no -1)
-                if ((posicion_barco(player, idx_ship, s_part, x, y)) && x != -1 && y != -1) {
-                    color_txt(ERROR_COLOR);
-                    printf("Solapamiento detectado en"); color_txt(INFO_COLOR); printf(" %d,%d", x, y);
-                    color_txt(DEFAULT_COLOR); printf(" con el barco %d", idx_ship + 1);
-                    color_txt(INFO_COLOR); printf(" CodeError: 4\n"); color_txt(DEFAULT_COLOR);
-                    return false; // Hay solapamiento
+            for (int idx_ship = 0; idx_ship < player->placed_ships; idx_ship++) {
+                for (s_part = 0; s_part < player->ships[idx_ship].size; s_part++) {
+                    if (posicion_barco(player, idx_ship, s_part, x, y)) {
+                        color_txt(ERROR_COLOR);
+                        printf("Solapamiento detectado en"); color_txt(INFO_COLOR); printf(" %d,%d", x, y);
+                        color_txt(DEFAULT_COLOR); printf(" con el barco %d", idx_ship + 1);
+                        color_txt(INFO_COLOR); printf(" CodeError: 4\n"); color_txt(DEFAULT_COLOR);
+                        return false; // Hay solapamiento
+                    }
                 }
             }
         }
diff --git a/codigo_fuente/src/bs_flow_card.c b/codigo_fuente/src/bs_flow_card.c
index 89f45a7..9de4f34 100644
--- a/codigo_fuente/src/bs_flow_card.c
+++ b/codigo_fuente/src/bs_flow_card.c
@@ -1,11 +1,9 @@
 #include "bs_flow_card.h"
-
-void funcion_carta_0(struct player *player, struct player *enemy) {
-    int disparos = player->salvo ? (NUM_SHIPS - enemy->sunked_ships) : 1;
-    for (int i = 0; i < disparos; i++) {
+static void shot_flow(struct player *player, struct player *enemy, int count) {
+    for (int i = 0; i < count; i++) {
         if (i == 0) {
             printf("Dispara una vez.\n");
-        } else if (i < disparos - 1) {
+        } else if (i < count - 1) {
             mostrar_turno_y_tablero_G(player, enemy);
             printf("Dispara de nuevo.\n");
         } else {
@@ -15,57 +13,38 @@ void funcion_carta_0(struct player *player, struct player *enemy) {
         pausa_consola(1.3);
         capturar_coordenada(player, enemy);
         enter_continuar();
-        mostrar_turno_y_tablero_G(player, enemy); // Mostrar el tablero después de disparar.
-        printf("Tablero de guerra actualizado:\n");
+        end_card_flow(player, enemy);
+        // if(!player->salvo) break; ← borrado, ya que el modo salvo se maneja en el conteo de funcion_carta_0
+    }
+}
+
+static void end_card_flow(struct player *player, struct player *enemy) {
+    // Mostrar el tablero de guerra después de usar la carta.
+    mostrar_turno_y_tablero_G(player, enemy);
+    printf("Tablero de guerra actualizado:\n");
+    if (player->last_card_id == 3 || player->last_card_id == 4
+        || player->last_card_id == 6 || player->last_card_id == 7) {
+        mostrar_bomb_cheq_exitoso(player); // Mostrar el resultado del bombardeo.
+    } else {
         mostrar_ultimo_disparo_exitoso(player); // Mostrar el último disparo exitoso.
-        pausa_consola(1);
-        if(player->salvo) {
-            enter_continuar();
-        } else break; // Si no es modo Salvo, salir del bucle después de un disparo.
     }
+    pausa_consola(1);
     enter_continuar();
 }
 
+void funcion_carta_0(struct player *player, struct player *enemy) {
+    int disparos = player->salvo 
+    ? (NUM_SHIPS - enemy->sunked_ships) : 1;
+
+    shot_flow(player, enemy, disparos);
+}
+
 void funcion_carta_1(struct player *player, struct player *enemy) {
-    // Primer disparo
-    for(int i = 1; i <= 2; i++) {
-        if (i == 1) {
-            printf("Dispara una vez.\n");
-        } else {
-            mostrar_turno_y_tablero_G(player, enemy);
-            printf("Dispara de nuevo.\n");
-        }
-        pausa_consola(1.3);
-        capturar_coordenada(player, enemy);
-        enter_continuar();
-        mostrar_turno_y_tablero_G(player, enemy);
-        printf("Tablero de guerra actualizado:\n");
-        mostrar_ultimo_disparo_exitoso(player);
-        pausa_consola(1);
-        enter_continuar();
-    }
+    shot_flow(player, enemy, 2);
 }
 
 void funcion_carta_2(struct player *player, struct player *enemy) {
-    for(int i = 1; i <= 3; i++) {
-        if (i == 1) {
-            printf("Dispara una vez.\n");
-        } else if (i == 2) {
-            mostrar_turno_y_tablero_G(player, enemy);
-            printf("Dispara de nuevo.\n");
-        } else {
-            mostrar_turno_y_tablero_G(player, enemy);
-            printf("Dispara una vez mas.\n");
-        }
-        pausa_consola(1.3);
-        capturar_coordenada(player, enemy);
-        enter_continuar();
-        mostrar_turno_y_tablero_G(player, enemy);
-        printf("Tablero de guerra actualizado:\n");
-        mostrar_ultimo_disparo_exitoso(player);
-        pausa_consola(1);
-        enter_continuar();
-    }
+    shot_flow(player, enemy, 3);
 }
 
 void funcion_carta_3(struct player *player, struct player *enemy) {
@@ -79,11 +58,7 @@ void funcion_carta_3(struct player *player, struct player *enemy) {
 
     }
     enter_continuar();
-    mostrar_turno_y_tablero_G(player, enemy);
-    printf("Tablero de guerra actualizado:\n");
-    mostrar_bomb_cheq_exitoso(player);
-    pausa_consola(1);
-    enter_continuar();
+    end_card_flow(player, enemy);
 }
 
 void funcion_carta_4(struct player *player, struct player *enemy) {
@@ -95,50 +70,44 @@ void funcion_carta_4(struct player *player, struct player *enemy) {
         printf("Solo pudimos activar la carta de 1 disparo.\n");
         capturar_coordenada(player, enemy);
     }
-
-    limpiar_buffer_entrada(); // Limpiar el buffer de entrada para evitar problemas con la entrada del usuario.
-    enter_continuar();
-    mostrar_turno_y_tablero_G(player, enemy);
-    printf("Tablero de guerra actualizado:\n");
-    mostrar_bomb_cheq_exitoso(player);
-    pausa_consola(1);
     enter_continuar();
+    end_card_flow(player, enemy);
 }
 
 void funcion_carta_5(struct player *player, struct player *enemy) {
     printf("Inteligencia a decifrado con exito la ubicacion de una casilla enemiga.\n");
-    revela(enemy, player);
+    revela(player, enemy);
     enter_continuar();
+    end_card_flow(player, enemy);
 }
 
 void funcion_carta_6(struct player *player, struct player *enemy) {
     printf("Hemos logrado activar el radar de filas.\n");
     capturar_fila_columna(player, enemy);
-    limpiar_buffer_entrada(); // Limpiar el buffer de entrada para evitar problemas con la entrada del usuario.
-    enter_continuar();
-    mostrar_turno_y_tablero_G(player, enemy);
-    printf("Tablero de guerra actualizado:\n");
-    mostrar_bomb_cheq_exitoso(player);
-    pausa_consola(1);
     enter_continuar();
+    end_card_flow(player, enemy);
 }
 
 void funcion_carta_7(struct player *player, struct player *enemy) {
     printf("Hemos logrado activar el radar de columnas.\n");
     capturar_fila_columna(player, enemy);
-    limpiar_buffer_entrada(); // Limpiar el buffer de entrada para evitar problemas con la entrada del usuario.
-    enter_continuar();
-    mostrar_turno_y_tablero_G(player, enemy);
-    printf("Tablero de guerra actualizado:\n");
-    mostrar_bomb_cheq_exitoso(player);
-    pausa_consola(1);
     enter_continuar();
+    end_card_flow(player, enemy);
 }
 
-void funcion_carta_8(struct player *player) {
+void funcion_carta_8(struct player *player, struct player *enemy) {
     activar_salvo(player);
     printf("\nModo Salvo activado\n");
     printf("Durante este turno NO disparas. En tu proximo turno, podras disparar multiples veces.\n");
+    pausa_consola(1);
+    enter_continuar();
+
+    mostrar_turno_y_tablero_G(player, enemy);
+    printf("Modo");
+    color_txt(SUCCESS_COLOR);
+        printf(" salvo");
+    color_txt(DEFAULT_COLOR);
+    printf(" actualizado:\n");
     pausa_consola(1.3);
     enter_continuar();
 }
@@ -152,19 +121,26 @@ void funcion_carta_9(struct player *player, struct player *enemy) {
     } else torre_ventaja(player);
     printf("En este turno no disparas.\n");
     enter_continuar();
-}
 
-void funcion_carta_10(struct player *player, struct player *enemy) {
-    printf("Puedes disparar una vez, luego podras agarrar otra carta.\n");
+    mostrar_turno_y_tablero_G(player, enemy);
+    printf("Torre de ");
+    color_txt(SUCCESS_COLOR);
+        printf("ventaja");
+    color_txt(DEFAULT_COLOR);
+    printf(" actualizada:\n");
     pausa_consola(1.3);
-    capturar_coordenada(player, enemy);
     enter_continuar();
-    mostrar_turno_y_tablero_G(player, enemy);
-    printf("Tablero de guerra actualizado:\n");
-    mostrar_ultimo_disparo_exitoso(player);
-    pausa_consola(1);
-    printf("Presiona enter para sacar otra carta.\n");
-    
+}
+
+void funcion_carta_10(struct player *player, struct player *enemy) {
+    shot_flow(player, enemy, 1); // Dispara una vez con la carta 10
+    printf("Presiona");
+    color_txt(INFO_COLOR);
+        printf(" ENTER");
+    color_txt(DEFAULT_COLOR);
+    printf(" para sacar otra carta.\n");
+    limpiar_buffer_entrada(); // Limpiar el buffer de entrada para evitar problemas con la entrada del usuario.
+
     sacar_carta(player, enemy);
 }
 
@@ -172,7 +148,6 @@ void funcion_carta_11(struct player *player, struct player *enemy) {
     printf("Puedes mover un barco hacia adelante");
     pausa_consola(1.3);
     solicitar_barco(player, enemy);
-    limpiar_buffer_entrada(); // Limpiar el buffer de entrada para evitar problemas con la entrada del usuario.
     enter_continuar();
     mostrar_turno_y_tablero(player);
     printf("Posicion de barco actualizada:\n");
diff --git a/codigo_fuente/src/bs_game.c b/codigo_fuente/src/bs_game.c
index ebfb47e..197ded3 100644
--- a/codigo_fuente/src/bs_game.c
+++ b/codigo_fuente/src/bs_game.c
@@ -16,13 +16,13 @@ void partida() {
     enter_continuar(); // Pausa antes de continuar.
     
     // Colocar barcos para el jugador 1.
-    colocar_barcos_jugador(&player1); // Colocar barcos para el jugador 1.
+    flow_colocar_barcos(&player1); // Colocar barcos para el jugador 1.
 
     // Colocar barcos para el jugador 2.
     printf("Ahora es turno de"); color_txt(INFO_COLOR); printf(" %s\n", player2.name); color_txt(DEFAULT_COLOR);
     enter_continuar(); // Pausa antes de continuar.
 
-    colocar_barcos_jugador(&player2);
+    flow_colocar_barcos(&player2);
 
     // Elegir aleatoriamente quién inicia
     decidir_primer_turno(&player1, &player2);
@@ -161,7 +161,7 @@ void sacar_carta(struct player *player, struct player *enemy) {
         funcion_carta_7(player, enemy); // Carta 7: Revela una columna enemiga
         break;
     case 8:
-        funcion_carta_8(player); // Carta 8: Activa el modo salvo
+        funcion_carta_8(player, enemy); // Carta 8: Activa el modo salvo
         break;
     case 9:
         funcion_carta_9(player, enemy); // Carta 9: Activa la torre de ventaja al acumular 4 torres
diff --git a/codigo_fuente/src/bs_logic.c b/codigo_fuente/src/bs_logic.c
index c8bb1b5..f3bd8e0 100644
--- a/codigo_fuente/src/bs_logic.c
+++ b/codigo_fuente/src/bs_logic.c
@@ -1,18 +1,11 @@
 #include "bs_logic.h"
 
-bool procesar_coordenadas(struct player *player, int index, int filaInicio, int filaFin, int columnaInicio, int columnaFin) {
-    bool validacion = false;
-
-        // Validar orientación de las coordenadas
-        if (validar_orientacion(player, index, filaInicio, filaFin, columnaInicio, columnaFin)) validacion = true;
-
-        // Validar dimensión de las coordenadas
-        if (validar_dimension(player, index, filaInicio, filaFin, columnaInicio, columnaFin)) validacion = true;
-
-        // Validar solapamiento de las coordenadas
-        if (validar_solapamiento(player, index, filaInicio, filaFin, columnaInicio, columnaFin)) validacion = true;
-
-    return validacion;
+bool procesar_coordenadas(struct player *player, int index, int filaIn, int filaFin, int columnaIn, int columnaFin) {
+    if (!validar_cc_rango(filaFin, columnaFin)) return false;
+    if (!validar_orientacion(player, index, filaIn, filaFin, columnaIn, columnaFin)) return false;
+    if (!validar_dimension(player, index, filaIn, filaFin, columnaIn, columnaFin)) return false;
+    if (!validar_solapamiento(player, index, filaIn, filaFin, columnaIn, columnaFin)) return false;
+    return true;
 }
 
 void colocar_barco_en_tablero(struct player *player, int index, int filaInicio, int filaFin, int columnaInicio, int columnaFin) {
diff --git a/codigo_fuente/src/bs_player.c b/codigo_fuente/src/bs_player.c
index 3c3d6c4..d806c15 100644
--- a/codigo_fuente/src/bs_player.c
+++ b/codigo_fuente/src/bs_player.c
@@ -96,7 +96,7 @@ void inicializar_cartas(struct player *player) {
                 break;
             case 10:
                 strcpy(player->cartas[i].nombre, "Tira y toma");
-                strcpy(player->cartas[i].descripcion, "Inserta coordenadas donde desees disparar y vuelve a generar una carta.");
+                strcpy(player->cartas[i].descripcion, "Inserta coordenadas donde desees disparar y vuelve a sacar una carta.");
                 player->cartas[i].peso = 1;
                 break;
             case 11:
diff --git a/codigo_fuente/src/bs_ui.c b/codigo_fuente/src/bs_ui.c
index 0d1dec6..85c56e1 100644
--- a/codigo_fuente/src/bs_ui.c
+++ b/codigo_fuente/src/bs_ui.c
@@ -180,24 +180,23 @@ void solicitar_nombre(struct player *player) {
     } while (1);
 }
 
-void colocar_barcos_jugador(struct player *player) {
-    printf("Colocando barcos para"); color_txt(INFO_COLOR); printf(" %s\n", player->name); color_txt(DEFAULT_COLOR);
+void tablero_colocar_barcos(struct player *player, int index) {
+    printf("Colocando barcos de"); color_txt(INFO_COLOR); printf(" %s\n", player->name); color_txt(DEFAULT_COLOR);
+    imprimirTablero(player);
+    printf("Coloca tu %s", player->ships[index].name); color_txt(INFO_COLOR); printf(" (%d ",player->ships[index].size); color_txt(DEFAULT_COLOR);
+    printf("celdas).\nBarco"); color_txt(INFO_COLOR); printf(" %d ",index + 1); color_txt(DEFAULT_COLOR);
+    printf("de"); color_txt(INFO_COLOR); printf(" %d\n",NUM_SHIPS); color_txt(DEFAULT_COLOR);
+}
+
+void flow_colocar_barcos(struct player *player) {
     for(int idx_ship = 0; idx_ship < NUM_SHIPS; idx_ship++) {
-        limpiar_pantalla();
-        printf("Colocando barcos de"); color_txt(INFO_COLOR); printf(" %s\n", player->name); color_txt(DEFAULT_COLOR);
-        imprimirTablero(player);
-        printf("Coloca tu %s", player->ships[idx_ship].name); color_txt(INFO_COLOR); printf(" (%d ",player->ships[idx_ship].size); color_txt(DEFAULT_COLOR);
-        printf("celdas).\nBarco"); color_txt(INFO_COLOR); printf(" %d ",idx_ship + 1); color_txt(DEFAULT_COLOR);
-        printf("de"); color_txt(INFO_COLOR); printf(" %d\n",NUM_SHIPS); color_txt(DEFAULT_COLOR);
         ponerBarcos(player, idx_ship);
     }
     printf("Colocando barcos de"); color_txt(INFO_COLOR); printf(" %s\n", player->name); color_txt(DEFAULT_COLOR);
     imprimirTablero(player);
     printf("Barcos colocados correctamente. \n");
     Sleep(1000);
-    limpiar_buffer_entrada();
     enter_continuar();
-    limpiar_pantalla();
 }
 
 void imprimirTablero(struct player *player) {
@@ -285,68 +284,118 @@ void imprimirTablero(struct player *player) {
 }
 
 void ponerBarcos(struct player *player, int index) {
-    int filaInicio, filaFin, columnaInicio, columnaFin;
-    char filaInicio_c, filaFin_c;
-    bool validacion = false;
-
-    do {
-        // Se le pide al usuario que ingrese las coordenadas iniciales y finales del barco.
-        puts("Coordenada inicial del barco (Fila: letras de A a la J; Columna: numero del 1 al 10): ");
+    int filaIn, filaFin, columnaIn, columnaFin;
+    char filaIn_c, filaFin_c;
+    char input[32]; // Buffer para la entrada del usuario
+
+    REINICIAL:
+    //-------------------------- Coordenada inicial ------------------------------
+    while (true) {
+        tablero_colocar_barcos(player, index);
+        printf("Coordenada inicial del barco (Fila: letras de A a la J; Columna: numero del 1 al 10): \n");
         printf("Ejemplo:"); color_txt(INFO_COLOR); printf("A 1"); color_txt(DEFAULT_COLOR);
         printf("\n> ");
 
-        if (scanf(" %c %d", &filaInicio_c, &columnaInicio) != 2) {
+        if(!fgets(input, sizeof(input), stdin)) continue; // Si falla la lectura, repetir
+        if (sscanf(input, " %c %d", &filaIn_c, &columnaIn) != 2) {
             limpiar_buffer_entrada(); // Limpiar el buffer de entrada
             color_txt(ERROR_COLOR);
             printf("Formato de entrada invalido.");
             color_txt(INFO_COLOR); printf("CodeError: 0\n"); color_txt(DEFAULT_COLOR);
-        } else validacion = true;
-        
-        columnaInicio--; // Ajustar columna a base 0
-
-        filaInicio_c = toupper(filaInicio_c); // Convertir a mayúscula para evitar problemas de comparación
-        filaInicio = filaInicio_c - 'A'; // Convertir letra a índice (A=0, B=1, ..., J=9)
-        if (validar_cc_rango(filaInicio, columnaInicio)) validacion = true; // Validar rango de coordenadas
+            color_txt(ERROR_COLOR);
+            printf("Intente de nuevo.\n");
+            color_txt(DEFAULT_COLOR);
+            enter_continuar(); // Esperar a que el usuario presione ENTER
+            continue; // Saltar al final del bucle para pedir de nuevo las coordenadas
+        }
+        filaIn_c = toupper((unsigned char)filaIn_c); // Convertir a mayúscula para evitar problemas de comparación
+        filaIn = filaIn_c - 'A'; // Convertir letra a índice (A=0, B=1, ..., J=9)
+        columnaIn--; // Ajustar columna a base 0
         
-        if (!validacion) color_txt(ERROR_COLOR); printf("Intente de nuevo.\n"); color_txt(DEFAULT_COLOR);
-    } while(!validacion);
-    
-    validacion = false; // Reiniciar la validacion para la siguiente entrada
-
-    do {
-        puts("Coordenada final del barco (Fila: letras de A a la J; Columna: numero del 1 al 10): ");
-        printf("Ejemplo:"); color_txt(INFO_COLOR); printf("A 1"); color_txt(DEFAULT_COLOR);
-        printf("\n> ");
+        if (!validar_cc_rango(filaIn, columnaIn)) {
+            enter_continuar(); // Esperar a que el usuario presione ENTER
+            continue; // Validar rango de coordenadas
+        }
+        if(!validar_solapamiento_inicial(player, index, filaIn, columnaIn)) {
+            enter_continuar(); // Esperar a que el usuario presione ENTER
+            continue; // Si hay solapamiento, continuar pidiendo coordenadas
+        }
+        while (true) { // Logica de confirmacion de coordenadas
+            printf("Presiona"); color_txt(INFO_COLOR); 
+            printf(" ENTER"); color_txt(DEFAULT_COLOR); printf(" para confirmar.\n");
+            printf("[Z]: Intentar de nuevo.\n");
+
+            if (!fgets(input, sizeof(input), stdin)) continue; // si falla la lectura, repetir
+            if (input[0] == '\n') break;
+            if (toupper((unsigned char)input[0]) == 'Z') {
+                limpiar_pantalla(); // Limpiar la pantalla antes de reingresar coordenada inicial
+                goto REINICIAL;
+            }
 
-        if (scanf(" %c %d", &filaFin_c, &columnaFin) != 2) {
-            limpiar_buffer_entrada(); // Limpiar el buffer de entrada
-            color_txt(ERROR_COLOR);
-            printf("Formato de entrada invalido.");
-            color_txt(INFO_COLOR); printf("CodeError: 0\n"); color_txt(DEFAULT_COLOR);
-        } else validacion = true;
+            color_txt(ERROR_COLOR); printf("Opcion invalida. Intente de nuevo\n");
+            color_txt(DEFAULT_COLOR);
+        }
+        limpiar_pantalla(); // Limpiar la pantalla después de confirmar coordenadas
+        break;
+    }
 
-        columnaFin--; // Ajustar columna a base 0
+REFINAL:
+    // --------------------------- Coordenada final ------------------------------
+    while (true) {
+        tablero_colocar_barcos(player, index);
+        printf("Coordenada final del barco (Fila: letras de A a la J; Columna: numero del 1 al 10): \n");
+        printf("[Z]: Reingresar coordenada inicial.\n");
+        printf("Ejemplo:"); color_txt(INFO_COLOR); printf("A 1\n"); color_txt(DEFAULT_COLOR);
+        printf("> ");
 
+        if (!fgets(input, sizeof(input), stdin)) continue;
+        if (toupper((unsigned char)input[0]) == 'Z') {
+            limpiar_pantalla(); // Limpiar la pantalla antes de reingresar coordenada inicial
+            goto REINICIAL;
+        } // Si el usuario quiere reingresar coordenada inicial
+        
+        if (sscanf(input, " %c %d", &filaFin_c, &columnaFin) != 2) {
+            color_txt(ERROR_COLOR); printf("Formato de entrada invalido.");
+            color_txt(INFO_COLOR); printf("CodeError: 0\n");
+            color_txt(ERROR_COLOR); printf("Intente de nuevo.\n"); color_txt(DEFAULT_COLOR);
+            enter_continuar(); // Esperar a que el usuario presione ENTER
+            continue;
+        }
         filaFin_c = toupper(filaFin_c); // Convertir a mayúscula para evitar problemas de comparación
         filaFin = filaFin_c - 'A'; // Convertir letra a índice (A=0, B=1, ..., J=9)
-        if (validar_cc_rango(filaFin, columnaFin)) validacion = true; // Validar rango de coordenadas
+        columnaFin--; // Ajustar columna a base 0
 
-        // Validar barco una vez validadas las coordenadas iniciales y finales.
-        if (procesar_coordenadas(player, index, filaInicio, filaFin, columnaInicio, columnaFin)) validacion = true; // Validaciones en conjunto
+        //validaciones
+        if (!procesar_coordenadas(player, index, filaIn, filaFin, columnaIn, columnaFin)) {
+            enter_continuar(); // Esperar a que el usuario presione ENTER
+            continue; 
+        }
+
+        while (true) {  // Logica de confirmacion de coordenadas
+            printf("Presiona"); color_txt(INFO_COLOR); 
+            printf(" ENTER"); color_txt(DEFAULT_COLOR); printf(" para confirmar.\n");
+            printf("[Z]: Intentar de nuevo.\n");
+
+            if (!fgets(input, sizeof(input), stdin)) continue; // si falla la lectura, repetir
+            if (input[0] == '\n') break;
+            if (toupper(input[0]) == 'Z') {
+                limpiar_pantalla(); // Limpiar la pantalla antes de reingresar coordenada final
+                goto REFINAL;
+            }
+            color_txt(ERROR_COLOR);
+            printf("Opcion invalida. Intente de nuevo\n");
+            color_txt(DEFAULT_COLOR);
+        }
+        colocar_barco_en_tablero(player, index, filaIn, filaFin, columnaIn, columnaFin);
+        player->placed_ships++; // Incrementar el contador de barcos colocados.
+        color_txt(SUCCESS_COLOR); printf("Barco colocado exitosamente de");
+        color_txt(INFO_COLOR); printf(" (%c, %d) ", filaIn_c, columnaIn + 1);
+        color_txt(DEFAULT_COLOR); printf("a");
+        color_txt(INFO_COLOR); printf(" (%c, %d)\n", filaFin_c, columnaFin + 1); color_txt(DEFAULT_COLOR);
+        pausa_consola(1.5); // Pausa para mostrar el mensaje de éxito.
+        break;
+    }
 
-        if (!validacion) color_txt(ERROR_COLOR); printf("Intente de nuevo.\n"); color_txt(DEFAULT_COLOR);
-    } while(!validacion);
-    
-    // Si las coordenadas son validas, colocar el barco en el tablero.
-    colocar_barco_en_tablero(player, index, filaInicio, filaFin, columnaInicio, columnaFin);
-    
-    color_txt(SUCCESS_COLOR);
-    printf("Barco colocado exitosamente de");
-    color_txt(INFO_COLOR);
-    printf(" (%c, %d) ", filaInicio_c, columnaInicio + 1);
-    color_txt(DEFAULT_COLOR); printf("a");
-    color_txt(INFO_COLOR); printf(" (%c, %d)\n", filaFin_c, columnaFin + 1); color_txt(DEFAULT_COLOR);
-    Sleep(1000); // Pausa para mostrar el mensaje de éxito.
     limpiar_pantalla(); // Limpiar la pantalla después de colocar el barco.
 }
 
@@ -378,10 +427,10 @@ void mostrar_turno_y_tablero_G(struct player *player, struct player *enemy) {
         color_txt(DEFAULT_COLOR);
     }
 
-    imprimirTableroGuerra(enemy, player); // Imprimir el tablero del enemigo.
+    imprimirTableroGuerra(player, enemy); // Imprimir el tablero del enemigo.
 }
 
-void imprimirTableroGuerra(struct player *enemy, struct player *player) {
+void imprimirTableroGuerra(struct player *player, struct player *enemy) {
     int anchoTablero, relleno, consolaAncho;
     int i, j, idx_ship, s_part, print_status;
     CONSOLE_SCREEN_BUFFER_INFO csbi;
@@ -760,44 +809,45 @@ void capturar_fila_columna(struct player *player, struct player *enemy) {
     }
 }
 
-void mostrar_bomb_cheq_exitoso(struct player *player_i) {
-        
-switch (player_i->last_card_id) {
+void mostrar_bomb_cheq_exitoso(struct player *player) {
+
+switch (player->last_card_id) {
     case 3:
-        if (player_i->last_successful_shot_fila != -1) {
-            printf("Bombardeo exitoso en la fila: %c\n", player_i->last_successful_shot_fila + 'A');
-            printf("Casillas enemigas destruidos: %d\n", player_i->aciertos_por_turno);
+        if (player->last_successful_shot_fila != -1) {
+            printf("Bombardeo exitoso en la fila: %c\n", player->last_successful_shot_fila + 'A');
+            printf("Casillas enemigas destruidos: %d\n", player->aciertos_por_turno);
         } else printf("No se ha realizado ningun bombardeo exitoso.\n");
         break;
     case 4:
-        if (player_i->last_successful_shot_columna != -1) {
-            printf("Bombardeo exitoso en la columna: %d\n", player_i->last_successful_shot_columna + 1);
-            printf("Casillas enemigas destruidos: %d\n", player_i->aciertos_por_turno);
+        if (player->last_successful_shot_columna != -1) {
+            printf("Bombardeo exitoso en la columna: %d\n", player->last_successful_shot_columna + 1);
+            printf("Casillas enemigas destruidos: %d\n", player->aciertos_por_turno);
         } else printf("No se ha realizado ningun bombardeo exitoso.\n");
         break;
     case 6:
-        printf("Chequeo exitoso en la fila: %c\n", player_i->ultima_fila_chequeada + 'A');
-        printf("Casillas enemigas encontradas: %d\n", player_i->contador_fila[player_i->ultima_fila_chequeada]);
+        printf("Chequeo exitoso en la fila: %c\n", player->ultima_fila_chequeada + 'A');
+        printf("Casillas enemigas encontradas: %d\n", player->contador_fila[player->ultima_fila_chequeada]);
         break;
     case 7:
-        printf("Chequeo exitoso en la columna: %d\n", player_i->ultima_columna_chequeada + 1);
-        printf("Casillas enemigas encontradas: %d\n", player_i->contador_columna[player_i->ultima_columna_chequeada]);
+        printf("Chequeo exitoso en la columna: %d\n", player->ultima_columna_chequeada + 1);
+        printf("Casillas enemigas encontradas: %d\n", player->contador_columna[player->ultima_columna_chequeada]);
         break;
     }
 }
 
-void solicitar_barco(struct player *player_i, struct player *enemy_i) {
+void solicitar_barco(struct player *player, struct player *enemy) {
     int i, barco_seleccionado;
     char opc;
+    bool loop = false;
     do {
         limpiar_pantalla();
-        printf("Turno de"); color_txt(INFO_COLOR); printf(" %s\n", player_i->name); color_txt(DEFAULT_COLOR);
-        imprimirTablero(player_i);    
+        printf("Turno de"); color_txt(INFO_COLOR); printf(" %s\n", player->name); color_txt(DEFAULT_COLOR);
+        imprimirTablero(player);
         printf("Seleccione el barco que desea mover:\n");
         for (i = 0; i < NUM_SHIPS; i++) {
-            if (validar_movimiento(player_i, &player_i->ships[i])) {
+            if (validar_movimiento(player, &player->ships[i])) {
                 // Mostrar solo barcos que se pueden mover
-                printf("Barco %d: %d celdas\n", i + 1, player_i->ships[i].size);
+                printf("Barco %d: %d celdas\n", i + 1, player->ships[i].size);
             }
         }
         printf("[z]: No mover ningun barco.\n");
@@ -807,19 +857,18 @@ void solicitar_barco(struct player *player_i, struct player *enemy_i) {
             case 'Z':
                 printf("No se movera ningun barco. Recibes una carta de"); color_txt(INFO_COLOR); printf(" disparo.\n");
                 color_txt(DEFAULT_COLOR);
-                capturar_coordenada(player_i, enemy_i);
-                return;
+                loop = false; // Salir del bucle
+                capturar_coordenada(player, enemy);
             case '1': case '2': case '3': case '4': case '5':
                 barco_seleccionado = opc - '1'; // Convertir a base 0
-                if (validar_movimiento(player_i, &player_i->ships[barco_seleccionado])) {       
-                    mover_barco_adelante(player_i, barco_seleccionado);
-                    return;
+                if (validar_movimiento(player, &player->ships[barco_seleccionado])) {
+                    mover_barco_adelante(player, barco_seleccionado);
                 } else {
                         color_txt(ERROR_COLOR);
                     printf("No puedes mover ese barco.\n");
                     color_txt(DEFAULT_COLOR);
                     Sleep(2000); // Pausa para mostrar el mensaje de error.
-                    break; // Salir del bucle si el barco no se puede mover
+                    continue; // Volver al inicio del bucle para seleccionar otro barco
                 }
                 break;
             default:
@@ -828,7 +877,7 @@ void solicitar_barco(struct player *player_i, struct player *enemy_i) {
                 color_txt(DEFAULT_COLOR);
                 Sleep(2000);
             }
-        } while (1);
+        } while (loop);
 }
 
 
